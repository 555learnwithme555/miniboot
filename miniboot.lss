
miniboot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000842  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000007ee  00007800  00007800  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00000842  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000874  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000048  00000000  00000000  000008b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000016b9  00000000  00000000  000008fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000a25  00000000  00000000  00001fb5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000713  00000000  00000000  000029da  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000310  00000000  00000000  000030f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000008f7  00000000  00000000  00003400  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000107b  00000000  00000000  00003cf7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000078  00000000  00000000  00004d72  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007800 <__vectors>:
    7800:	33 c0       	rjmp	.+102    	; 0x7868 <__ctors_end>
    7802:	00 00       	nop
    7804:	39 c0       	rjmp	.+114    	; 0x7878 <__bad_interrupt>
    7806:	00 00       	nop
    7808:	37 c0       	rjmp	.+110    	; 0x7878 <__bad_interrupt>
    780a:	00 00       	nop
    780c:	35 c0       	rjmp	.+106    	; 0x7878 <__bad_interrupt>
    780e:	00 00       	nop
    7810:	33 c0       	rjmp	.+102    	; 0x7878 <__bad_interrupt>
    7812:	00 00       	nop
    7814:	31 c0       	rjmp	.+98     	; 0x7878 <__bad_interrupt>
    7816:	00 00       	nop
    7818:	2f c0       	rjmp	.+94     	; 0x7878 <__bad_interrupt>
    781a:	00 00       	nop
    781c:	2d c0       	rjmp	.+90     	; 0x7878 <__bad_interrupt>
    781e:	00 00       	nop
    7820:	2b c0       	rjmp	.+86     	; 0x7878 <__bad_interrupt>
    7822:	00 00       	nop
    7824:	29 c0       	rjmp	.+82     	; 0x7878 <__bad_interrupt>
    7826:	00 00       	nop
    7828:	27 c0       	rjmp	.+78     	; 0x7878 <__bad_interrupt>
    782a:	00 00       	nop
    782c:	25 c0       	rjmp	.+74     	; 0x7878 <__bad_interrupt>
    782e:	00 00       	nop
    7830:	23 c0       	rjmp	.+70     	; 0x7878 <__bad_interrupt>
    7832:	00 00       	nop
    7834:	21 c0       	rjmp	.+66     	; 0x7878 <__bad_interrupt>
    7836:	00 00       	nop
    7838:	1f c0       	rjmp	.+62     	; 0x7878 <__bad_interrupt>
    783a:	00 00       	nop
    783c:	1d c0       	rjmp	.+58     	; 0x7878 <__bad_interrupt>
    783e:	00 00       	nop
    7840:	1b c0       	rjmp	.+54     	; 0x7878 <__bad_interrupt>
    7842:	00 00       	nop
    7844:	19 c0       	rjmp	.+50     	; 0x7878 <__bad_interrupt>
    7846:	00 00       	nop
    7848:	17 c0       	rjmp	.+46     	; 0x7878 <__bad_interrupt>
    784a:	00 00       	nop
    784c:	15 c0       	rjmp	.+42     	; 0x7878 <__bad_interrupt>
    784e:	00 00       	nop
    7850:	13 c0       	rjmp	.+38     	; 0x7878 <__bad_interrupt>
    7852:	00 00       	nop
    7854:	11 c0       	rjmp	.+34     	; 0x7878 <__bad_interrupt>
    7856:	00 00       	nop
    7858:	0f c0       	rjmp	.+30     	; 0x7878 <__bad_interrupt>
    785a:	00 00       	nop
    785c:	0d c0       	rjmp	.+26     	; 0x7878 <__bad_interrupt>
    785e:	00 00       	nop
    7860:	0b c0       	rjmp	.+22     	; 0x7878 <__bad_interrupt>
    7862:	00 00       	nop
    7864:	09 c0       	rjmp	.+18     	; 0x7878 <__bad_interrupt>
	...

00007868 <__ctors_end>:
    7868:	11 24       	eor	r1, r1
    786a:	1f be       	out	0x3f, r1	; 63
    786c:	cf ef       	ldi	r28, 0xFF	; 255
    786e:	d8 e0       	ldi	r29, 0x08	; 8
    7870:	de bf       	out	0x3e, r29	; 62
    7872:	cd bf       	out	0x3d, r28	; 61
    7874:	cb d2       	rcall	.+1430   	; 0x7e0c <main>
    7876:	b9 c3       	rjmp	.+1906   	; 0x7fea <_exit>

00007878 <__bad_interrupt>:
    7878:	c3 cf       	rjmp	.-122    	; 0x7800 <__vectors>

0000787a <_ZL12writeToFlashjPhRj>:
static inline uint16_t getDataLength(const uint8_t i2c_address) {
  return getWordFromSource(i2c_address, application_length_byte_offset);
}

static inline void writeToFlash(const uint16_t address, uint8_t *data,
                                uint16_t &application_start) {
    787a:	cf 93       	push	r28
    787c:	df 93       	push	r29
    787e:	db 01       	movw	r26, r22

  if (0 == address) {
    7880:	00 97       	sbiw	r24, 0x00	; 0
    7882:	b1 f4       	brne	.+44     	; 0x78b0 <_ZL12writeToFlashjPhRj+0x36>
    application_start = static_cast<uint8_t>(
        static_cast<uint16_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS] << 8));
    7884:	fa 01       	movw	r30, r20
    7886:	11 82       	std	Z+1, r1	; 0x01
    7888:	10 82       	st	Z, r1
    application_start |=
        static_cast<uint8_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS + 1]);
    788a:	13 96       	adiw	r26, 0x03	; 3
    788c:	2c 91       	ld	r18, X
    788e:	13 97       	sbiw	r26, 0x03	; 3
    7890:	30 e0       	ldi	r19, 0x00	; 0
    7892:	31 83       	std	Z+1, r19	; 0x01
    7894:	20 83       	st	Z, r18

    data[RESET_VECTOR] = static_cast<uint8_t>(jmp_instruction);
    7896:	2c e0       	ldi	r18, 0x0C	; 12
    7898:	2c 93       	st	X, r18
    data[RESET_VECTOR + 1] = static_cast<uint8_t>(jmp_instruction >> 8);
    789a:	24 e9       	ldi	r18, 0x94	; 148
    789c:	11 96       	adiw	r26, 0x01	; 1
    789e:	2c 93       	st	X, r18
    78a0:	11 97       	sbiw	r26, 0x01	; 1

    data[RESET_VECTOR_ARGUMENT_ADDRESS] = static_cast<uint8_t>(
        static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2);
    78a2:	12 96       	adiw	r26, 0x02	; 2
    78a4:	1c 92       	st	X, r1
    78a6:	12 97       	sbiw	r26, 0x02	; 2
    data[RESET_VECTOR_ARGUMENT_ADDRESS + 1] = static_cast<uint8_t>(
        (static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2) >> 8);
    78a8:	2c e3       	ldi	r18, 0x3C	; 60
    78aa:	13 96       	adiw	r26, 0x03	; 3
    78ac:	2c 93       	st	X, r18
    78ae:	13 97       	sbiw	r26, 0x03	; 3
  } while (ptr);
  wdt_reset();
}

static inline void erasePage(const uint16_t address) {
  boot_page_erase(address);
    78b0:	23 e0       	ldi	r18, 0x03	; 3
    78b2:	fc 01       	movw	r30, r24
    78b4:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    78b8:	e8 95       	spm
  boot_spm_busy_wait();
    78ba:	07 b6       	in	r0, 0x37	; 55
    78bc:	00 fc       	sbrc	r0, 0
    78be:	fd cf       	rjmp	.-6      	; 0x78ba <_ZL12writeToFlashjPhRj+0x40>
    78c0:	40 e0       	ldi	r20, 0x00	; 0
    78c2:	50 e0       	ldi	r21, 0x00	; 0
static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  erasePage(address);
  for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
    uint16_t w = *data++;
    w += (*data++) << 8;
    boot_page_fill(address + i, w);
    78c4:	61 e0       	ldi	r22, 0x01	; 1
}

static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  erasePage(address);
  for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
    uint16_t w = *data++;
    78c6:	7c 91       	ld	r23, X
    78c8:	12 96       	adiw	r26, 0x02	; 2
    78ca:	fa 01       	movw	r30, r20
    78cc:	e8 0f       	add	r30, r24
    78ce:	f9 1f       	adc	r31, r25
    78d0:	ed 01       	movw	r28, r26
    78d2:	21 97       	sbiw	r28, 0x01	; 1
    w += (*data++) << 8;
    78d4:	28 81       	ld	r18, Y
    78d6:	30 e0       	ldi	r19, 0x00	; 0
    78d8:	32 2f       	mov	r19, r18
    78da:	22 27       	eor	r18, r18
    78dc:	27 0f       	add	r18, r23
    78de:	31 1d       	adc	r19, r1
    boot_page_fill(address + i, w);
    78e0:	09 01       	movw	r0, r18
    78e2:	60 93 57 00 	sts	0x0057, r22	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    78e6:	e8 95       	spm
    78e8:	11 24       	eor	r1, r1
    78ea:	4e 5f       	subi	r20, 0xFE	; 254
    78ec:	5f 4f       	sbci	r21, 0xFF	; 255
  boot_spm_busy_wait();
}

static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  erasePage(address);
  for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
    78ee:	40 38       	cpi	r20, 0x80	; 128
    78f0:	51 05       	cpc	r21, r1
    78f2:	49 f7       	brne	.-46     	; 0x78c6 <_ZL12writeToFlashjPhRj+0x4c>
    boot_page_fill(address + i, w);
  }
}

static inline void writePageBufferToFlash(const uint16_t address) {
  boot_page_write(address);
    78f4:	25 e0       	ldi	r18, 0x05	; 5
    78f6:	fc 01       	movw	r30, r24
    78f8:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    78fc:	e8 95       	spm
  boot_spm_busy_wait();
    78fe:	07 b6       	in	r0, 0x37	; 55
    7900:	00 fc       	sbrc	r0, 0
    7902:	fd cf       	rjmp	.-6      	; 0x78fe <_ZL12writeToFlashjPhRj+0x84>
  boot_rww_enable();
    7904:	81 e1       	ldi	r24, 0x11	; 17
    7906:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    790a:	e8 95       	spm
  }

  writeToPageBuffer(address, data);
  writePageBufferToFlash(address);
}
    790c:	df 91       	pop	r29
    790e:	cf 91       	pop	r28
    7910:	08 95       	ret

00007912 <_Z47writeLatestApplicationTimestampToInternalEepromm>:
  boot_spm_busy_wait();
}
#endif // #if 0

void writeLatestApplicationTimestampToInternalEeprom(
    const uint32_t latest_timestamp) {
    7912:	cf 92       	push	r12
    7914:	df 92       	push	r13
    7916:	ef 92       	push	r14
    7918:	ff 92       	push	r15
    791a:	6b 01       	movw	r12, r22
    791c:	7c 01       	movw	r14, r24
  eeprom_write_byte(
      reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE),
      latest_timestamp >> 24);
    791e:	6f 2d       	mov	r22, r15
    7920:	77 27       	eor	r23, r23
    7922:	88 27       	eor	r24, r24
    7924:	99 27       	eor	r25, r25
    7926:	86 ef       	ldi	r24, 0xF6	; 246
    7928:	93 e0       	ldi	r25, 0x03	; 3
    792a:	51 d3       	rcall	.+1698   	; 0x7fce <eeprom_write_byte>
  eeprom_write_byte(
      reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 1),
      latest_timestamp >> 16);
    792c:	b7 01       	movw	r22, r14
    792e:	88 27       	eor	r24, r24
    7930:	99 27       	eor	r25, r25
    7932:	87 ef       	ldi	r24, 0xF7	; 247
    7934:	93 e0       	ldi	r25, 0x03	; 3
    7936:	4b d3       	rcall	.+1686   	; 0x7fce <eeprom_write_byte>
  eeprom_write_byte(
      reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 2),
      latest_timestamp >> 8);
    7938:	99 27       	eor	r25, r25
    793a:	8f 2d       	mov	r24, r15
    793c:	7e 2d       	mov	r23, r14
    793e:	6d 2d       	mov	r22, r13
    7940:	88 ef       	ldi	r24, 0xF8	; 248
    7942:	93 e0       	ldi	r25, 0x03	; 3
    7944:	44 d3       	rcall	.+1672   	; 0x7fce <eeprom_write_byte>
  eeprom_write_byte(
      reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 3),
      latest_timestamp);
    7946:	6c 2d       	mov	r22, r12
    7948:	89 ef       	ldi	r24, 0xF9	; 249
    794a:	93 e0       	ldi	r25, 0x03	; 3
    794c:	40 d3       	rcall	.+1664   	; 0x7fce <eeprom_write_byte>
  boot_spm_busy_wait();
    794e:	07 b6       	in	r0, 0x37	; 55
    7950:	00 fc       	sbrc	r0, 0
    7952:	fd cf       	rjmp	.-6      	; 0x794e <_Z47writeLatestApplicationTimestampToInternalEepromm+0x3c>
}
    7954:	ff 90       	pop	r15
    7956:	ef 90       	pop	r14
    7958:	df 90       	pop	r13
    795a:	cf 90       	pop	r12
    795c:	08 95       	ret

0000795e <_Z48readLatestApplicationTimestampFromInternalEepromv>:

uint32_t readLatestApplicationTimestampFromInternalEeprom() {
    795e:	cf 92       	push	r12
    7960:	df 92       	push	r13
    7962:	ef 92       	push	r14
    7964:	ff 92       	push	r15
    7966:	cf 93       	push	r28
  uint32_t result =
      static_cast<uint32_t>(eeprom_read_byte(
          reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE)))
    7968:	86 ef       	ldi	r24, 0xF6	; 246
    796a:	93 e0       	ldi	r25, 0x03	; 3
    796c:	28 d3       	rcall	.+1616   	; 0x7fbe <eeprom_read_byte>
      << 24;
    796e:	c8 2e       	mov	r12, r24
    7970:	d1 2c       	mov	r13, r1
    7972:	e1 2c       	mov	r14, r1
    7974:	f1 2c       	mov	r15, r1
    7976:	fc 2c       	mov	r15, r12
    7978:	ee 24       	eor	r14, r14
    797a:	dd 24       	eor	r13, r13
    797c:	cc 24       	eor	r12, r12
  result |= static_cast<uint32_t>(eeprom_read_byte(reinterpret_cast<uint8_t *>(
                EEPROM_CONFIGURATION_START_BYTE + 1)))
    797e:	87 ef       	ldi	r24, 0xF7	; 247
    7980:	93 e0       	ldi	r25, 0x03	; 3
    7982:	1d d3       	rcall	.+1594   	; 0x7fbe <eeprom_read_byte>
            << 16;
    7984:	e8 2a       	or	r14, r24
  result |= static_cast<uint32_t>(eeprom_read_byte(reinterpret_cast<uint8_t *>(
                EEPROM_CONFIGURATION_START_BYTE + 2)))
    7986:	88 ef       	ldi	r24, 0xF8	; 248
    7988:	93 e0       	ldi	r25, 0x03	; 3
    798a:	19 d3       	rcall	.+1586   	; 0x7fbe <eeprom_read_byte>
    798c:	c8 2f       	mov	r28, r24
            << 8;
  result |= static_cast<uint32_t>(eeprom_read_byte(
      reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 3)));
    798e:	89 ef       	ldi	r24, 0xF9	; 249
    7990:	93 e0       	ldi	r25, 0x03	; 3
    7992:	15 d3       	rcall	.+1578   	; 0x7fbe <eeprom_read_byte>
    7994:	a7 01       	movw	r20, r14
    7996:	96 01       	movw	r18, r12
    7998:	28 2b       	or	r18, r24
    799a:	da 01       	movw	r26, r20
    799c:	c9 01       	movw	r24, r18
    799e:	bc 01       	movw	r22, r24
    79a0:	cd 01       	movw	r24, r26
    79a2:	7c 2b       	or	r23, r28
  boot_spm_busy_wait();
    79a4:	07 b6       	in	r0, 0x37	; 55
    79a6:	00 fc       	sbrc	r0, 0
    79a8:	fd cf       	rjmp	.-6      	; 0x79a4 <_Z48readLatestApplicationTimestampFromInternalEepromv+0x46>
  return result;
}
    79aa:	cf 91       	pop	r28
    79ac:	ff 90       	pop	r15
    79ae:	ef 90       	pop	r14
    79b0:	df 90       	pop	r13
    79b2:	cf 90       	pop	r12
    79b4:	08 95       	ret

000079b6 <_Z8readBytehj>:
#pragma once

#include "I2C-master-lib/i2c_master.h"

uint8_t readByte(const uint8_t source_address,
                 const uint16_t register_address) {
    79b6:	1f 93       	push	r17
    79b8:	cf 93       	push	r28
    79ba:	df 93       	push	r29
    79bc:	00 d0       	rcall	.+0      	; 0x79be <_Z8readBytehj+0x8>
    79be:	cd b7       	in	r28, 0x3d	; 61
    79c0:	de b7       	in	r29, 0x3e	; 62
  uint8_t data = 0xFF;
  uint8_t write_source_address = source_address << 1;
    79c2:	18 2f       	mov	r17, r24
    79c4:	11 0f       	add	r17, r17
  i2c_start(write_source_address);
    79c6:	81 2f       	mov	r24, r17
    79c8:	6a 83       	std	Y+2, r22	; 0x02
    79ca:	79 83       	std	Y+1, r23	; 0x01
    79cc:	fb d0       	rcall	.+502    	; 0x7bc4 <_Z9i2c_starth>
  i2c_write(register_address >> 8);
    79ce:	79 81       	ldd	r23, Y+1	; 0x01
    79d0:	87 2f       	mov	r24, r23
    79d2:	1a d1       	rcall	.+564    	; 0x7c08 <_Z9i2c_writeh>
  i2c_write(register_address);
    79d4:	6a 81       	ldd	r22, Y+2	; 0x02
    79d6:	86 2f       	mov	r24, r22
    79d8:	17 d1       	rcall	.+558    	; 0x7c08 <_Z9i2c_writeh>
  i2c_stop();
    79da:	14 d2       	rcall	.+1064   	; 0x7e04 <_Z8i2c_stopv>

  uint8_t read_source_address = write_source_address | 0x01;
  i2c_start(read_source_address);
    79dc:	81 2f       	mov	r24, r17
    79de:	81 60       	ori	r24, 0x01	; 1
    79e0:	f1 d0       	rcall	.+482    	; 0x7bc4 <_Z9i2c_starth>
  data = i2c_read_ack();

  return data;
}
    79e2:	0f 90       	pop	r0
    79e4:	0f 90       	pop	r0
    79e6:	df 91       	pop	r29
    79e8:	cf 91       	pop	r28
    79ea:	1f 91       	pop	r17
  i2c_write(register_address);
  i2c_stop();

  uint8_t read_source_address = write_source_address | 0x01;
  i2c_start(read_source_address);
  data = i2c_read_ack();
    79ec:	1e c1       	rjmp	.+572    	; 0x7c2a <_Z12i2c_read_ackv>

000079ee <_ZL17getWordFromSourcehj.constprop.5>:

  return data;
}

static uint16_t getWordFromSource(const uint8_t i2c_address,
    79ee:	0f 93       	push	r16
    79f0:	1f 93       	push	r17
    79f2:	cf 93       	push	r28
    79f4:	df 93       	push	r29
    79f6:	8c 01       	movw	r16, r24
                                  const uint16_t data_address) {
  uint16_t result = static_cast<uint16_t>(readByte(i2c_address, data_address))
    79f8:	bc 01       	movw	r22, r24
    79fa:	80 e5       	ldi	r24, 0x50	; 80
    79fc:	dc df       	rcall	.-72     	; 0x79b6 <_Z8readBytehj>
                    << 8;
    79fe:	c8 2f       	mov	r28, r24
    7a00:	d0 e0       	ldi	r29, 0x00	; 0
    7a02:	dc 2f       	mov	r29, r28
    7a04:	cc 27       	eor	r28, r28
  result |= static_cast<uint16_t>(readByte(i2c_address, data_address + 1));
    7a06:	b8 01       	movw	r22, r16
    7a08:	6f 5f       	subi	r22, 0xFF	; 255
    7a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    7a0c:	80 e5       	ldi	r24, 0x50	; 80
    7a0e:	d3 df       	rcall	.-90     	; 0x79b6 <_Z8readBytehj>
  return result;
}
    7a10:	9e 01       	movw	r18, r28
    7a12:	28 2b       	or	r18, r24
    7a14:	c9 01       	movw	r24, r18
    7a16:	df 91       	pop	r29
    7a18:	cf 91       	pop	r28
    7a1a:	1f 91       	pop	r17
    7a1c:	0f 91       	pop	r16
    7a1e:	08 95       	ret

00007a20 <_ZL7isCrcOkh.constprop.3>:

static inline bool isCrcOk(const uint8_t i2c_address) {
    7a20:	3f 92       	push	r3
    7a22:	4f 92       	push	r4
    7a24:	5f 92       	push	r5
    7a26:	6f 92       	push	r6
    7a28:	7f 92       	push	r7
    7a2a:	8f 92       	push	r8
    7a2c:	9f 92       	push	r9
    7a2e:	af 92       	push	r10
    7a30:	bf 92       	push	r11
    7a32:	cf 92       	push	r12
    7a34:	df 92       	push	r13
    7a36:	ef 92       	push	r14
    7a38:	ff 92       	push	r15
    7a3a:	0f 93       	push	r16
    7a3c:	1f 93       	push	r17
    7a3e:	cf 93       	push	r28
    7a40:	df 93       	push	r29
    7a42:	cd b7       	in	r28, 0x3d	; 61
    7a44:	de b7       	in	r29, 0x3e	; 62
    7a46:	d4 50       	subi	r29, 0x04	; 4
    7a48:	0f b6       	in	r0, 0x3f	; 63
    7a4a:	f8 94       	cli
    7a4c:	de bf       	out	0x3e, r29	; 62
    7a4e:	0f be       	out	0x3f, r0	; 63
    7a50:	cd bf       	out	0x3d, r28	; 61
static inline uint16_t getDataStartAddressInSource(const uint8_t i2c_address) {
  return application_byte_offset;
}

static inline uint16_t getDataLength(const uint8_t i2c_address) {
  return getWordFromSource(i2c_address, application_length_byte_offset);
    7a52:	80 e2       	ldi	r24, 0x20	; 32
    7a54:	90 e0       	ldi	r25, 0x00	; 0
    7a56:	cb df       	rcall	.-106    	; 0x79ee <_ZL17getWordFromSourcehj.constprop.5>
    7a58:	8c 01       	movw	r16, r24
    7a5a:	fe 01       	movw	r30, r28
    7a5c:	31 96       	adiw	r30, 0x01	; 1
    7a5e:	80 e0       	ldi	r24, 0x00	; 0
    7a60:	90 e0       	ldi	r25, 0x00	; 0
    7a62:	dc 01       	movw	r26, r24
    7a64:	5f 01       	movw	r10, r30
    7a66:	ac 01       	movw	r20, r24
    7a68:	bd 01       	movw	r22, r26
    7a6a:	28 e0       	ldi	r18, 0x08	; 8
static constexpr uint32_t polynomial_representation = 0xEDB88320UL;
static constexpr uint16_t crc_table_size = 0x100;

static inline uint32_t crc32_for_byte(uint32_t r) {
  for (uint8_t i = 0; i < 8; ++i) {
    r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
    7a6c:	40 fd       	sbrc	r20, 0
    7a6e:	09 c0       	rjmp	.+18     	; 0x7a82 <_ZL7isCrcOkh.constprop.3+0x62>
    7a70:	30 e2       	ldi	r19, 0x20	; 32
    7a72:	c3 2e       	mov	r12, r19
    7a74:	33 e8       	ldi	r19, 0x83	; 131
    7a76:	d3 2e       	mov	r13, r19
    7a78:	38 eb       	ldi	r19, 0xB8	; 184
    7a7a:	e3 2e       	mov	r14, r19
    7a7c:	3d ee       	ldi	r19, 0xED	; 237
    7a7e:	f3 2e       	mov	r15, r19
    7a80:	03 c0       	rjmp	.+6      	; 0x7a88 <_ZL7isCrcOkh.constprop.3+0x68>
    7a82:	c1 2c       	mov	r12, r1
    7a84:	d1 2c       	mov	r13, r1
    7a86:	76 01       	movw	r14, r12
    7a88:	76 95       	lsr	r23
    7a8a:	67 95       	ror	r22
    7a8c:	57 95       	ror	r21
    7a8e:	47 95       	ror	r20
    7a90:	4c 25       	eor	r20, r12
    7a92:	5d 25       	eor	r21, r13
    7a94:	6e 25       	eor	r22, r14
    7a96:	7f 25       	eor	r23, r15
    7a98:	21 50       	subi	r18, 0x01	; 1

static constexpr uint32_t polynomial_representation = 0xEDB88320UL;
static constexpr uint16_t crc_table_size = 0x100;

static inline uint32_t crc32_for_byte(uint32_t r) {
  for (uint8_t i = 0; i < 8; ++i) {
    7a9a:	41 f7       	brne	.-48     	; 0x7a6c <_ZL7isCrcOkh.constprop.3+0x4c>
    r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
  }
  return r ^ (uint32_t)0xFF000000L;
    7a9c:	70 95       	com	r23
}

static inline void init_table(uint32_t *crc_table) {
  for (uint16_t i = 0; i < crc_table_size; ++i) {
    crc_table[i] = crc32_for_byte(i);
    7a9e:	41 93       	st	Z+, r20
    7aa0:	51 93       	st	Z+, r21
    7aa2:	61 93       	st	Z+, r22
    7aa4:	71 93       	st	Z+, r23
    7aa6:	01 96       	adiw	r24, 0x01	; 1
    7aa8:	a1 1d       	adc	r26, r1
    7aaa:	b1 1d       	adc	r27, r1
  }
  return r ^ (uint32_t)0xFF000000L;
}

static inline void init_table(uint32_t *crc_table) {
  for (uint16_t i = 0; i < crc_table_size; ++i) {
    7aac:	81 15       	cp	r24, r1
    7aae:	21 e0       	ldi	r18, 0x01	; 1
    7ab0:	92 07       	cpc	r25, r18
    7ab2:	a1 05       	cpc	r26, r1
    7ab4:	b1 05       	cpc	r27, r1
    7ab6:	b9 f6       	brne	.-82     	; 0x7a66 <_ZL7isCrcOkh.constprop.3+0x46>
    7ab8:	c1 2c       	mov	r12, r1
    7aba:	d1 2c       	mov	r13, r1
    7abc:	76 01       	movw	r14, r12
    7abe:	41 2c       	mov	r4, r1
    7ac0:	51 2c       	mov	r5, r1
  uint16_t length = getDataLength(i2c_address);

  uint32_t table[crc_table_size];
  init_table(&table[0]);

  for (uint16_t pos = 0; pos < length + 1;
    7ac2:	48 01       	movw	r8, r16
    7ac4:	8f ef       	ldi	r24, 0xFF	; 255
    7ac6:	88 1a       	sub	r8, r24
    7ac8:	98 0a       	sbc	r9, r24
       pos += 2) { // length +1 in case of odd number lengths
    if (pos >= length)
      break;

    uint16_t data = getWordFromSource(i2c_address, pos + start_address);
    if (pos == length - 1)
    7aca:	38 01       	movw	r6, r16
    7acc:	91 e0       	ldi	r25, 0x01	; 1
    7ace:	69 1a       	sub	r6, r25
    7ad0:	71 08       	sbc	r7, r1
    crc32(reinterpret_cast<const void *>(&to_little_endian[0]), 2, &table[0],
          &crc);

    uint8_t toggle_led_every_x_bytes = 128;
    if (0 == pos % toggle_led_every_x_bytes)
      LED_TOGGLE();
    7ad2:	33 24       	eor	r3, r3
    7ad4:	33 94       	inc	r3
  uint16_t length = getDataLength(i2c_address);

  uint32_t table[crc_table_size];
  init_table(&table[0]);

  for (uint16_t pos = 0; pos < length + 1;
    7ad6:	48 14       	cp	r4, r8
    7ad8:	59 04       	cpc	r5, r9
    7ada:	e0 f5       	brcc	.+120    	; 0x7b54 <_ZL7isCrcOkh.constprop.3+0x134>
       pos += 2) { // length +1 in case of odd number lengths
    if (pos >= length)
    7adc:	40 16       	cp	r4, r16
    7ade:	51 06       	cpc	r5, r17
    7ae0:	c8 f5       	brcc	.+114    	; 0x7b54 <_ZL7isCrcOkh.constprop.3+0x134>
      break;

    uint16_t data = getWordFromSource(i2c_address, pos + start_address);
    7ae2:	c2 01       	movw	r24, r4
    7ae4:	82 96       	adiw	r24, 0x22	; 34
    7ae6:	83 df       	rcall	.-250    	; 0x79ee <_ZL17getWordFromSourcehj.constprop.5>
    if (pos == length - 1)
    7ae8:	46 14       	cp	r4, r6
    7aea:	57 04       	cpc	r5, r7
    7aec:	09 f4       	brne	.+2      	; 0x7af0 <_ZL7isCrcOkh.constprop.3+0xd0>
      data &= 0xFF00;
    7aee:	88 27       	eor	r24, r24
}

static inline void crc32(const void *data, const uint16_t length,
                         const uint32_t *crc_table, uint32_t *crc) {
  for (uint16_t i = 0; i < length; ++i) {
    *crc = crc_table[static_cast<uint8_t>(*crc) ^ ((uint8_t *)data)[i]] ^
    7af0:	9c 25       	eor	r25, r12
           *crc >> 8;
    7af2:	cd 2c       	mov	r12, r13
    7af4:	de 2c       	mov	r13, r14
    7af6:	ef 2c       	mov	r14, r15
    7af8:	ff 24       	eor	r15, r15
}

static inline void crc32(const void *data, const uint16_t length,
                         const uint32_t *crc_table, uint32_t *crc) {
  for (uint16_t i = 0; i < length; ++i) {
    *crc = crc_table[static_cast<uint8_t>(*crc) ^ ((uint8_t *)data)[i]] ^
    7afa:	f5 01       	movw	r30, r10
    7afc:	24 e0       	ldi	r18, 0x04	; 4
    7afe:	92 9f       	mul	r25, r18
    7b00:	e0 0d       	add	r30, r0
    7b02:	f1 1d       	adc	r31, r1
    7b04:	11 24       	eor	r1, r1
    7b06:	40 81       	ld	r20, Z
    7b08:	51 81       	ldd	r21, Z+1	; 0x01
    7b0a:	62 81       	ldd	r22, Z+2	; 0x02
    7b0c:	73 81       	ldd	r23, Z+3	; 0x03
    7b0e:	c4 26       	eor	r12, r20
    7b10:	d5 26       	eor	r13, r21
    7b12:	e6 26       	eor	r14, r22
    7b14:	f7 26       	eor	r15, r23
    7b16:	8c 25       	eor	r24, r12
           *crc >> 8;
    7b18:	cd 2c       	mov	r12, r13
    7b1a:	de 2c       	mov	r13, r14
    7b1c:	ef 2c       	mov	r14, r15
    7b1e:	ff 24       	eor	r15, r15
}

static inline void crc32(const void *data, const uint16_t length,
                         const uint32_t *crc_table, uint32_t *crc) {
  for (uint16_t i = 0; i < length; ++i) {
    *crc = crc_table[static_cast<uint8_t>(*crc) ^ ((uint8_t *)data)[i]] ^
    7b20:	f5 01       	movw	r30, r10
    7b22:	94 e0       	ldi	r25, 0x04	; 4
    7b24:	89 9f       	mul	r24, r25
    7b26:	e0 0d       	add	r30, r0
    7b28:	f1 1d       	adc	r31, r1
    7b2a:	11 24       	eor	r1, r1
    7b2c:	80 81       	ld	r24, Z
    7b2e:	91 81       	ldd	r25, Z+1	; 0x01
    7b30:	a2 81       	ldd	r26, Z+2	; 0x02
    7b32:	b3 81       	ldd	r27, Z+3	; 0x03
    7b34:	c8 26       	eor	r12, r24
    7b36:	d9 26       	eor	r13, r25
    7b38:	ea 26       	eor	r14, r26
    7b3a:	fb 26       	eor	r15, r27

    crc32(reinterpret_cast<const void *>(&to_little_endian[0]), 2, &table[0],
          &crc);

    uint8_t toggle_led_every_x_bytes = 128;
    if (0 == pos % toggle_led_every_x_bytes)
    7b3c:	c2 01       	movw	r24, r4
    7b3e:	8f 77       	andi	r24, 0x7F	; 127
    7b40:	99 27       	eor	r25, r25
    7b42:	89 2b       	or	r24, r25
    7b44:	19 f4       	brne	.+6      	; 0x7b4c <_ZL7isCrcOkh.constprop.3+0x12c>
      LED_TOGGLE();
    7b46:	85 b1       	in	r24, 0x05	; 5
    7b48:	83 25       	eor	r24, r3
    7b4a:	85 b9       	out	0x05, r24	; 5
  uint16_t length = getDataLength(i2c_address);

  uint32_t table[crc_table_size];
  init_table(&table[0]);

  for (uint16_t pos = 0; pos < length + 1;
    7b4c:	22 e0       	ldi	r18, 0x02	; 2
    7b4e:	42 0e       	add	r4, r18
    7b50:	51 1c       	adc	r5, r1
    7b52:	c1 cf       	rjmp	.-126    	; 0x7ad6 <_ZL7isCrcOkh.constprop.3+0xb6>
    if (0 == pos % toggle_led_every_x_bytes)
      LED_TOGGLE();
  }

  uint32_t expected_crc = static_cast<uint32_t>(getWordFromSource(
                              i2c_address, application_crc_expected_index))
    7b54:	8c e1       	ldi	r24, 0x1C	; 28
    7b56:	90 e0       	ldi	r25, 0x00	; 0
    7b58:	4a df       	rcall	.-364    	; 0x79ee <_ZL17getWordFromSourcehj.constprop.5>
                          << 16;
    7b5a:	ac 01       	movw	r20, r24
    7b5c:	60 e0       	ldi	r22, 0x00	; 0
    7b5e:	70 e0       	ldi	r23, 0x00	; 0
    7b60:	5a 01       	movw	r10, r20
    7b62:	99 24       	eor	r9, r9
    7b64:	88 24       	eor	r8, r8
  expected_crc |= static_cast<uint32_t>(
      getWordFromSource(i2c_address, application_crc_expected_index + 2));
    7b66:	8e e1       	ldi	r24, 0x1E	; 30
    7b68:	90 e0       	ldi	r25, 0x00	; 0
    7b6a:	41 df       	rcall	.-382    	; 0x79ee <_ZL17getWordFromSourcehj.constprop.5>
    7b6c:	8c 01       	movw	r16, r24
    7b6e:	20 e0       	ldi	r18, 0x00	; 0
    7b70:	30 e0       	ldi	r19, 0x00	; 0
    7b72:	b5 01       	movw	r22, r10
    7b74:	a4 01       	movw	r20, r8
    7b76:	40 2b       	or	r20, r16
    7b78:	51 2b       	or	r21, r17
    7b7a:	62 2b       	or	r22, r18
    7b7c:	73 2b       	or	r23, r19

  if (crc == expected_crc) {
    7b7e:	81 e0       	ldi	r24, 0x01	; 1
    7b80:	c4 16       	cp	r12, r20
    7b82:	d5 06       	cpc	r13, r21
    7b84:	e6 06       	cpc	r14, r22
    7b86:	f7 06       	cpc	r15, r23
    7b88:	09 f0       	breq	.+2      	; 0x7b8c <_ZL7isCrcOkh.constprop.3+0x16c>
    7b8a:	80 e0       	ldi	r24, 0x00	; 0
    status = true;
  }
  return status;
}
    7b8c:	dc 5f       	subi	r29, 0xFC	; 252
    7b8e:	0f b6       	in	r0, 0x3f	; 63
    7b90:	f8 94       	cli
    7b92:	de bf       	out	0x3e, r29	; 62
    7b94:	0f be       	out	0x3f, r0	; 63
    7b96:	cd bf       	out	0x3d, r28	; 61
    7b98:	df 91       	pop	r29
    7b9a:	cf 91       	pop	r28
    7b9c:	1f 91       	pop	r17
    7b9e:	0f 91       	pop	r16
    7ba0:	ff 90       	pop	r15
    7ba2:	ef 90       	pop	r14
    7ba4:	df 90       	pop	r13
    7ba6:	cf 90       	pop	r12
    7ba8:	bf 90       	pop	r11
    7baa:	af 90       	pop	r10
    7bac:	9f 90       	pop	r9
    7bae:	8f 90       	pop	r8
    7bb0:	7f 90       	pop	r7
    7bb2:	6f 90       	pop	r6
    7bb4:	5f 90       	pop	r5
    7bb6:	4f 90       	pop	r4
    7bb8:	3f 90       	pop	r3
    7bba:	08 95       	ret

00007bbc <_Z8i2c_initv>:

#define F_SCL 100000UL // SCL frequency
#define Prescaler 1
#define TWBR_val ((((F_CPU / F_SCL) / Prescaler) - 16) / 2)

void i2c_init(void) { TWBR = (uint8_t)TWBR_val; }
    7bbc:	80 e2       	ldi	r24, 0x20	; 32
    7bbe:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7e00b8>
    7bc2:	08 95       	ret

00007bc4 <_Z9i2c_starth>:

uint8_t i2c_start(uint8_t address) {
  // reset TWI control register
  TWCR = 0;
    7bc4:	10 92 bc 00 	sts	0x00BC, r1	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  // transmit START condition
  TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    7bc8:	94 ea       	ldi	r25, 0xA4	; 164
    7bca:	90 93 bc 00 	sts	0x00BC, r25	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  // wait for end of transmission
  while (!(TWCR & (1 << TWINT)))
    7bce:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7bd2:	97 ff       	sbrs	r25, 7
    7bd4:	fc cf       	rjmp	.-8      	; 0x7bce <_Z9i2c_starth+0xa>
    ;

  // check if the start condition was successfully transmitted
  if ((TWSR & 0xF8) != TW_START) {
    7bd6:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7bda:	98 7f       	andi	r25, 0xF8	; 248
    7bdc:	98 30       	cpi	r25, 0x08	; 8
    7bde:	11 f0       	breq	.+4      	; 0x7be4 <_Z9i2c_starth+0x20>
    return 1;
    7be0:	81 e0       	ldi	r24, 0x01	; 1
    7be2:	08 95       	ret
  }

  // load slave address into data register
  TWDR = address;
    7be4:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
  // start transmission of address
  TWCR = (1 << TWINT) | (1 << TWEN);
    7be8:	84 e8       	ldi	r24, 0x84	; 132
    7bea:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  // wait for end of transmission
  while (!(TWCR & (1 << TWINT)))
    7bee:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7bf2:	87 ff       	sbrs	r24, 7
    7bf4:	fc cf       	rjmp	.-8      	; 0x7bee <_Z9i2c_starth+0x2a>
    ;

  // check if the device has acknowledged the READ / WRITE mode
  uint8_t twst = TW_STATUS & 0xF8;
    7bf6:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7bfa:	88 7f       	andi	r24, 0xF8	; 248
  if ((twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK))
    7bfc:	88 31       	cpi	r24, 0x18	; 24
    7bfe:	11 f0       	breq	.+4      	; 0x7c04 <_Z9i2c_starth+0x40>
    7c00:	80 34       	cpi	r24, 0x40	; 64
    7c02:	71 f7       	brne	.-36     	; 0x7be0 <_Z9i2c_starth+0x1c>
    return 1;

  return 0;
    7c04:	80 e0       	ldi	r24, 0x00	; 0
}
    7c06:	08 95       	ret

00007c08 <_Z9i2c_writeh>:

uint8_t i2c_write(uint8_t data) {
  // load data into data register
  TWDR = data;
    7c08:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
  // start transmission of data
  TWCR = (1 << TWINT) | (1 << TWEN);
    7c0c:	84 e8       	ldi	r24, 0x84	; 132
    7c0e:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  // wait for end of transmission
  while (!(TWCR & (1 << TWINT)))
    7c12:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7c16:	87 ff       	sbrs	r24, 7
    7c18:	fc cf       	rjmp	.-8      	; 0x7c12 <_Z9i2c_writeh+0xa>
    ;

  if ((TWSR & 0xF8) != TW_MT_DATA_ACK) {
    7c1a:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
    7c1e:	98 7f       	andi	r25, 0xF8	; 248
    7c20:	81 e0       	ldi	r24, 0x01	; 1
    7c22:	98 32       	cpi	r25, 0x28	; 40
    7c24:	09 f4       	brne	.+2      	; 0x7c28 <_Z9i2c_writeh+0x20>
    7c26:	80 e0       	ldi	r24, 0x00	; 0
    return 1;
  }

  return 0;
}
    7c28:	08 95       	ret

00007c2a <_Z12i2c_read_ackv>:

uint8_t i2c_read_ack(void) {

  // start TWI module and acknowledge data after reception
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
    7c2a:	84 ec       	ldi	r24, 0xC4	; 196
    7c2c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  // wait for end of transmission
  while (!(TWCR & (1 << TWINT)))
    7c30:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7c34:	87 ff       	sbrs	r24, 7
    7c36:	fc cf       	rjmp	.-8      	; 0x7c30 <_Z12i2c_read_ackv+0x6>
    ;
  // return received data from TWDR
  return TWDR;
    7c38:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
}
    7c3c:	08 95       	ret

00007c3e <_Z13i2c_read_nackv>:

uint8_t i2c_read_nack(void) {

  // start receiving without acknowledging reception
  TWCR = (1 << TWINT) | (1 << TWEN);
    7c3e:	84 e8       	ldi	r24, 0x84	; 132
    7c40:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  // wait for end of transmission
  while (!(TWCR & (1 << TWINT)))
    7c44:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7c48:	87 ff       	sbrs	r24, 7
    7c4a:	fc cf       	rjmp	.-8      	; 0x7c44 <_Z13i2c_read_nackv+0x6>
    ;
  // return received data from TWDR
  return TWDR;
    7c4c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
}
    7c50:	08 95       	ret

00007c52 <_Z12i2c_transmithPhj>:

uint8_t i2c_transmit(uint8_t address, uint8_t *data, uint16_t length) {
    7c52:	cf 92       	push	r12
    7c54:	df 92       	push	r13
    7c56:	ef 92       	push	r14
    7c58:	ff 92       	push	r15
    7c5a:	1f 93       	push	r17
    7c5c:	cf 93       	push	r28
    7c5e:	df 93       	push	r29
    7c60:	00 d0       	rcall	.+0      	; 0x7c62 <_Z12i2c_transmithPhj+0x10>
    7c62:	cd b7       	in	r28, 0x3d	; 61
    7c64:	de b7       	in	r29, 0x3e	; 62
    7c66:	7a 01       	movw	r14, r20
  if (i2c_start(address | I2C_WRITE))
    7c68:	69 83       	std	Y+1, r22	; 0x01
    7c6a:	7a 83       	std	Y+2, r23	; 0x02
    7c6c:	ab df       	rcall	.-170    	; 0x7bc4 <_Z9i2c_starth>
    7c6e:	18 2f       	mov	r17, r24
    7c70:	69 81       	ldd	r22, Y+1	; 0x01
    7c72:	7a 81       	ldd	r23, Y+2	; 0x02
    7c74:	81 11       	cpse	r24, r1
    7c76:	0c c0       	rjmp	.+24     	; 0x7c90 <_Z12i2c_transmithPhj+0x3e>
    7c78:	6b 01       	movw	r12, r22
    7c7a:	ec 0c       	add	r14, r12
    7c7c:	fd 1c       	adc	r15, r13
    return 1;

  for (uint16_t i = 0; i < length; i++) {
    7c7e:	ce 14       	cp	r12, r14
    7c80:	df 04       	cpc	r13, r15
    7c82:	41 f0       	breq	.+16     	; 0x7c94 <_Z12i2c_transmithPhj+0x42>
    if (i2c_write(data[i]))
    7c84:	f6 01       	movw	r30, r12
    7c86:	81 91       	ld	r24, Z+
    7c88:	6f 01       	movw	r12, r30
    7c8a:	be df       	rcall	.-132    	; 0x7c08 <_Z9i2c_writeh>
    7c8c:	88 23       	and	r24, r24
    7c8e:	b9 f3       	breq	.-18     	; 0x7c7e <_Z12i2c_transmithPhj+0x2c>
  return TWDR;
}

uint8_t i2c_transmit(uint8_t address, uint8_t *data, uint16_t length) {
  if (i2c_start(address | I2C_WRITE))
    return 1;
    7c90:	11 e0       	ldi	r17, 0x01	; 1
    7c92:	03 c0       	rjmp	.+6      	; 0x7c9a <_Z12i2c_transmithPhj+0x48>
  return 0;
}

void i2c_stop(void) {
  // transmit STOP condition
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
    7c94:	84 e9       	ldi	r24, 0x94	; 148
    7c96:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  }

  i2c_stop();

  return 0;
}
    7c9a:	81 2f       	mov	r24, r17
    7c9c:	0f 90       	pop	r0
    7c9e:	0f 90       	pop	r0
    7ca0:	df 91       	pop	r29
    7ca2:	cf 91       	pop	r28
    7ca4:	1f 91       	pop	r17
    7ca6:	ff 90       	pop	r15
    7ca8:	ef 90       	pop	r14
    7caa:	df 90       	pop	r13
    7cac:	cf 90       	pop	r12
    7cae:	08 95       	ret

00007cb0 <_Z11i2c_receivehPhj>:

uint8_t i2c_receive(uint8_t address, uint8_t *data, uint16_t length) {
    7cb0:	af 92       	push	r10
    7cb2:	bf 92       	push	r11
    7cb4:	cf 92       	push	r12
    7cb6:	df 92       	push	r13
    7cb8:	ff 92       	push	r15
    7cba:	0f 93       	push	r16
    7cbc:	1f 93       	push	r17
    7cbe:	cf 93       	push	r28
    7cc0:	df 93       	push	r29
    7cc2:	6b 01       	movw	r12, r22
    7cc4:	8a 01       	movw	r16, r20
  if (i2c_start(address | I2C_READ))
    7cc6:	81 60       	ori	r24, 0x01	; 1
    7cc8:	7d df       	rcall	.-262    	; 0x7bc4 <_Z9i2c_starth>
    7cca:	f8 2e       	mov	r15, r24
    7ccc:	81 11       	cpse	r24, r1
    7cce:	16 c0       	rjmp	.+44     	; 0x7cfc <_Z11i2c_receivehPhj+0x4c>
    7cd0:	56 01       	movw	r10, r12
    return 1;

  for (uint16_t i = 0; i < (length - 1); i++) {
    7cd2:	e8 01       	movw	r28, r16
    7cd4:	21 97       	sbiw	r28, 0x01	; 1
    7cd6:	c5 01       	movw	r24, r10
    7cd8:	8c 19       	sub	r24, r12
    7cda:	9d 09       	sbc	r25, r13
    7cdc:	8c 17       	cp	r24, r28
    7cde:	9d 07       	cpc	r25, r29
    7ce0:	28 f4       	brcc	.+10     	; 0x7cec <_Z11i2c_receivehPhj+0x3c>
    data[i] = i2c_read_ack();
    7ce2:	a3 df       	rcall	.-186    	; 0x7c2a <_Z12i2c_read_ackv>
    7ce4:	f5 01       	movw	r30, r10
    7ce6:	81 93       	st	Z+, r24
    7ce8:	5f 01       	movw	r10, r30
    7cea:	f5 cf       	rjmp	.-22     	; 0x7cd6 <_Z11i2c_receivehPhj+0x26>
  }
  data[(length - 1)] = i2c_read_nack();
    7cec:	cc 0d       	add	r28, r12
    7cee:	dd 1d       	adc	r29, r13
    7cf0:	a6 df       	rcall	.-180    	; 0x7c3e <_Z13i2c_read_nackv>
    7cf2:	88 83       	st	Y, r24
  return 0;
}

void i2c_stop(void) {
  // transmit STOP condition
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
    7cf4:	84 e9       	ldi	r24, 0x94	; 148
    7cf6:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  }
  data[(length - 1)] = i2c_read_nack();

  i2c_stop();

  return 0;
    7cfa:	02 c0       	rjmp	.+4      	; 0x7d00 <_Z11i2c_receivehPhj+0x50>
  return 0;
}

uint8_t i2c_receive(uint8_t address, uint8_t *data, uint16_t length) {
  if (i2c_start(address | I2C_READ))
    return 1;
    7cfc:	ff 24       	eor	r15, r15
    7cfe:	f3 94       	inc	r15
  data[(length - 1)] = i2c_read_nack();

  i2c_stop();

  return 0;
}
    7d00:	8f 2d       	mov	r24, r15
    7d02:	df 91       	pop	r29
    7d04:	cf 91       	pop	r28
    7d06:	1f 91       	pop	r17
    7d08:	0f 91       	pop	r16
    7d0a:	ff 90       	pop	r15
    7d0c:	df 90       	pop	r13
    7d0e:	cf 90       	pop	r12
    7d10:	bf 90       	pop	r11
    7d12:	af 90       	pop	r10
    7d14:	08 95       	ret

00007d16 <_Z12i2c_writeReghhPhj>:

uint8_t i2c_writeReg(uint8_t devaddr, uint8_t regaddr, uint8_t *data,
                     uint16_t length) {
    7d16:	af 92       	push	r10
    7d18:	bf 92       	push	r11
    7d1a:	df 92       	push	r13
    7d1c:	ef 92       	push	r14
    7d1e:	ff 92       	push	r15
    7d20:	0f 93       	push	r16
    7d22:	1f 93       	push	r17
    7d24:	cf 93       	push	r28
    7d26:	df 93       	push	r29
    7d28:	1f 92       	push	r1
    7d2a:	cd b7       	in	r28, 0x3d	; 61
    7d2c:	de b7       	in	r29, 0x3e	; 62
    7d2e:	d4 2e       	mov	r13, r20
    7d30:	05 2f       	mov	r16, r21
    7d32:	79 01       	movw	r14, r18
  if (i2c_start(devaddr | 0x00))
    7d34:	69 83       	std	Y+1, r22	; 0x01
    7d36:	46 df       	rcall	.-372    	; 0x7bc4 <_Z9i2c_starth>
    7d38:	18 2f       	mov	r17, r24
    7d3a:	69 81       	ldd	r22, Y+1	; 0x01
    7d3c:	88 23       	and	r24, r24
    7d3e:	11 f0       	breq	.+4      	; 0x7d44 <_Z12i2c_writeReghhPhj+0x2e>
    return 1;
    7d40:	11 e0       	ldi	r17, 0x01	; 1
    7d42:	13 c0       	rjmp	.+38     	; 0x7d6a <_Z12i2c_writeReghhPhj+0x54>

  i2c_write(regaddr);
    7d44:	86 2f       	mov	r24, r22
    7d46:	60 df       	rcall	.-320    	; 0x7c08 <_Z9i2c_writeh>
    7d48:	ad 2c       	mov	r10, r13
    7d4a:	b0 2e       	mov	r11, r16
    7d4c:	ea 0c       	add	r14, r10
    7d4e:	fb 1c       	adc	r15, r11

  for (uint16_t i = 0; i < length; i++) {
    7d50:	ae 14       	cp	r10, r14
    7d52:	bf 04       	cpc	r11, r15
    7d54:	39 f0       	breq	.+14     	; 0x7d64 <_Z12i2c_writeReghhPhj+0x4e>
    if (i2c_write(data[i]))
    7d56:	f5 01       	movw	r30, r10
    7d58:	81 91       	ld	r24, Z+
    7d5a:	5f 01       	movw	r10, r30
    7d5c:	55 df       	rcall	.-342    	; 0x7c08 <_Z9i2c_writeh>
    7d5e:	88 23       	and	r24, r24
    7d60:	b9 f3       	breq	.-18     	; 0x7d50 <_Z12i2c_writeReghhPhj+0x3a>
    7d62:	ee cf       	rjmp	.-36     	; 0x7d40 <_Z12i2c_writeReghhPhj+0x2a>
  return 0;
}

void i2c_stop(void) {
  // transmit STOP condition
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
    7d64:	84 e9       	ldi	r24, 0x94	; 148
    7d66:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  }

  i2c_stop();

  return 0;
}
    7d6a:	81 2f       	mov	r24, r17
    7d6c:	0f 90       	pop	r0
    7d6e:	df 91       	pop	r29
    7d70:	cf 91       	pop	r28
    7d72:	1f 91       	pop	r17
    7d74:	0f 91       	pop	r16
    7d76:	ff 90       	pop	r15
    7d78:	ef 90       	pop	r14
    7d7a:	df 90       	pop	r13
    7d7c:	bf 90       	pop	r11
    7d7e:	af 90       	pop	r10
    7d80:	08 95       	ret

00007d82 <_Z11i2c_readReghhPhj>:

uint8_t i2c_readReg(uint8_t devaddr, uint8_t regaddr, uint8_t *data,
                    uint16_t length) {
    7d82:	af 92       	push	r10
    7d84:	bf 92       	push	r11
    7d86:	cf 92       	push	r12
    7d88:	df 92       	push	r13
    7d8a:	ff 92       	push	r15
    7d8c:	0f 93       	push	r16
    7d8e:	1f 93       	push	r17
    7d90:	cf 93       	push	r28
    7d92:	df 93       	push	r29
    7d94:	1f 92       	push	r1
    7d96:	cd b7       	in	r28, 0x3d	; 61
    7d98:	de b7       	in	r29, 0x3e	; 62
    7d9a:	f8 2e       	mov	r15, r24
    7d9c:	6a 01       	movw	r12, r20
    7d9e:	89 01       	movw	r16, r18
  if (i2c_start(devaddr))
    7da0:	69 83       	std	Y+1, r22	; 0x01
    7da2:	10 df       	rcall	.-480    	; 0x7bc4 <_Z9i2c_starth>
    7da4:	69 81       	ldd	r22, Y+1	; 0x01
    7da6:	88 23       	and	r24, r24
    7da8:	19 f0       	breq	.+6      	; 0x7db0 <_Z11i2c_readReghhPhj+0x2e>
    return 1;
    7daa:	ff 24       	eor	r15, r15
    7dac:	f3 94       	inc	r15
    7dae:	1e c0       	rjmp	.+60     	; 0x7dec <_Z11i2c_readReghhPhj+0x6a>

  i2c_write(regaddr);
    7db0:	86 2f       	mov	r24, r22
    7db2:	2a df       	rcall	.-428    	; 0x7c08 <_Z9i2c_writeh>

  if (i2c_start(devaddr | 0x01))
    7db4:	8f 2d       	mov	r24, r15
    7db6:	81 60       	ori	r24, 0x01	; 1
    7db8:	05 df       	rcall	.-502    	; 0x7bc4 <_Z9i2c_starth>
    7dba:	f8 2e       	mov	r15, r24
    7dbc:	81 11       	cpse	r24, r1
    7dbe:	f5 cf       	rjmp	.-22     	; 0x7daa <_Z11i2c_readReghhPhj+0x28>
    7dc0:	56 01       	movw	r10, r12
    return 1;

  for (uint16_t i = 0; i < (length - 1); i++) {
    7dc2:	01 50       	subi	r16, 0x01	; 1
    7dc4:	11 09       	sbc	r17, r1
    7dc6:	c5 01       	movw	r24, r10
    7dc8:	8c 19       	sub	r24, r12
    7dca:	9d 09       	sbc	r25, r13
    7dcc:	80 17       	cp	r24, r16
    7dce:	91 07       	cpc	r25, r17
    7dd0:	28 f4       	brcc	.+10     	; 0x7ddc <_Z11i2c_readReghhPhj+0x5a>
    data[i] = i2c_read_ack();
    7dd2:	2b df       	rcall	.-426    	; 0x7c2a <_Z12i2c_read_ackv>
    7dd4:	f5 01       	movw	r30, r10
    7dd6:	81 93       	st	Z+, r24
    7dd8:	5f 01       	movw	r10, r30
    7dda:	f5 cf       	rjmp	.-22     	; 0x7dc6 <_Z11i2c_readReghhPhj+0x44>
  }
  data[(length - 1)] = i2c_read_nack();
    7ddc:	c0 0e       	add	r12, r16
    7dde:	d1 1e       	adc	r13, r17
    7de0:	2e df       	rcall	.-420    	; 0x7c3e <_Z13i2c_read_nackv>
    7de2:	f6 01       	movw	r30, r12
    7de4:	80 83       	st	Z, r24
  return 0;
}

void i2c_stop(void) {
  // transmit STOP condition
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
    7de6:	84 e9       	ldi	r24, 0x94	; 148
    7de8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
  data[(length - 1)] = i2c_read_nack();

  i2c_stop();

  return 0;
}
    7dec:	8f 2d       	mov	r24, r15
    7dee:	0f 90       	pop	r0
    7df0:	df 91       	pop	r29
    7df2:	cf 91       	pop	r28
    7df4:	1f 91       	pop	r17
    7df6:	0f 91       	pop	r16
    7df8:	ff 90       	pop	r15
    7dfa:	df 90       	pop	r13
    7dfc:	cf 90       	pop	r12
    7dfe:	bf 90       	pop	r11
    7e00:	af 90       	pop	r10
    7e02:	08 95       	ret

00007e04 <_Z8i2c_stopv>:

void i2c_stop(void) {
  // transmit STOP condition
  TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWSTO);
    7e04:	84 e9       	ldi	r24, 0x94	; 148
    7e06:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    7e0a:	08 95       	ret

00007e0c <main>:
  if (i2c_application_timestamp > current_application_timestamp)
    return true;
  return false;
}

int main() {
    7e0c:	cf 93       	push	r28
    7e0e:	df 93       	push	r29
    7e10:	cd b7       	in	r28, 0x3d	; 61
    7e12:	de b7       	in	r29, 0x3e	; 62
    7e14:	c2 58       	subi	r28, 0x82	; 130
    7e16:	d1 09       	sbc	r29, r1
    7e18:	0f b6       	in	r0, 0x3f	; 63
    7e1a:	f8 94       	cli
    7e1c:	de bf       	out	0x3e, r29	; 62
    7e1e:	0f be       	out	0x3f, r0	; 63
    7e20:	cd bf       	out	0x3d, r28	; 61
#include <avr/wdt.h>

static void initIO() { LED_INIT(); }

static void disableWatchdog() {
  wdt_reset();
    7e22:	a8 95       	wdr
  MCUSR = 0;
    7e24:	14 be       	out	0x34, r1	; 52
  WDTCSR |= (1 << WDCE) | (1 << WDE);
    7e26:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
    7e2a:	88 61       	ori	r24, 0x18	; 24
    7e2c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
  WDTCSR = 0;
    7e30:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__TEXT_REGION_LENGTH__+0x7e0060>
  asm("cli");
    7e34:	f8 94       	cli
}

static void init() {
  disableWatchdog();
  i2c_init();
    7e36:	c2 de       	rcall	.-636    	; 0x7bbc <_Z8i2c_initv>

#include "I2C-master-lib/i2c_master.h"
#include "io.h"
#include <avr/wdt.h>

static void initIO() { LED_INIT(); }
    7e38:	28 9a       	sbi	0x05, 0	; 5
    7e3a:	81 e0       	ldi	r24, 0x01	; 1
    7e3c:	84 b9       	out	0x04, r24	; 4

  init();

  uint32_t i2c_application_timestamp;
  uint16_t application_start = 0;
    7e3e:	cf 57       	subi	r28, 0x7F	; 127
    7e40:	df 4f       	sbci	r29, 0xFF	; 255
    7e42:	19 82       	std	Y+1, r1	; 0x01
    7e44:	18 82       	st	Y, r1
    7e46:	c1 58       	subi	r28, 0x81	; 129
    7e48:	d0 40       	sbci	r29, 0x00	; 0
    ;
}

static inline bool isReflashNecessary(uint32_t &i2c_application_timestamp) {
  uint32_t current_application_timestamp =
      readLatestApplicationTimestampFromInternalEeprom();
    7e4a:	89 dd       	rcall	.-1262   	; 0x795e <_Z48readLatestApplicationTimestampFromInternalEepromv>
    7e4c:	4b 01       	movw	r8, r22
    7e4e:	5c 01       	movw	r10, r24

  i2c_application_timestamp =
      static_cast<uint32_t>(getWordFromSource(
          source_i2c_address_for_program, timestamp_application_byte_offset))
    7e50:	84 e1       	ldi	r24, 0x14	; 20
    7e52:	90 e0       	ldi	r25, 0x00	; 0
    7e54:	cc dd       	rcall	.-1128   	; 0x79ee <_ZL17getWordFromSourcehj.constprop.5>
      << 16;
    7e56:	2c 01       	movw	r4, r24
    7e58:	61 2c       	mov	r6, r1
    7e5a:	71 2c       	mov	r7, r1
    7e5c:	72 01       	movw	r14, r4
    7e5e:	dd 24       	eor	r13, r13
    7e60:	cc 24       	eor	r12, r12
  i2c_application_timestamp |= static_cast<uint32_t>(getWordFromSource(
      source_i2c_address_for_program, timestamp_application_byte_offset + 2));
    7e62:	86 e1       	ldi	r24, 0x16	; 22
    7e64:	90 e0       	ldi	r25, 0x00	; 0
    7e66:	c3 dd       	rcall	.-1146   	; 0x79ee <_ZL17getWordFromSourcehj.constprop.5>
    7e68:	2c 01       	movw	r4, r24
    7e6a:	61 2c       	mov	r6, r1
    7e6c:	71 2c       	mov	r7, r1
    7e6e:	4c 28       	or	r4, r12
    7e70:	5d 28       	or	r5, r13
    7e72:	6e 28       	or	r6, r14
    7e74:	7f 28       	or	r7, r15

  if (eeprom_not_programmed == current_application_timestamp)
    7e76:	2f ef       	ldi	r18, 0xFF	; 255
    7e78:	82 16       	cp	r8, r18
    7e7a:	92 06       	cpc	r9, r18
    7e7c:	a2 06       	cpc	r10, r18
    7e7e:	b2 06       	cpc	r11, r18
    7e80:	c9 f0       	breq	.+50     	; 0x7eb4 <main+0xa8>
    return true;
  if (i2c_application_timestamp > current_application_timestamp)
    7e82:	84 14       	cp	r8, r4
    7e84:	95 04       	cpc	r9, r5
    7e86:	a6 04       	cpc	r10, r6
    7e88:	b7 04       	cpc	r11, r7
    7e8a:	a0 f0       	brcs	.+40     	; 0x7eb4 <main+0xa8>
    eraseApplication();
    writeFlashFromI2C(source_i2c_address_for_program, application_start);
    writeLatestApplicationTimestampToInternalEeprom(i2c_application_timestamp);
  } else {
    uint16_t address_in_external_eeprom = getWordFromSource(
        source_i2c_address_for_program, application_start_address_byte_offset);
    7e8c:	84 e2       	ldi	r24, 0x24	; 36
    7e8e:	90 e0       	ldi	r25, 0x00	; 0
    7e90:	ae dd       	rcall	.-1188   	; 0x79ee <_ZL17getWordFromSourcehj.constprop.5>

    application_start = address_in_external_eeprom >> 8;
    7e92:	09 2f       	mov	r16, r25
    7e94:	10 e0       	ldi	r17, 0x00	; 0
    application_start |= static_cast<uint8_t>(address_in_external_eeprom);
    7e96:	08 2b       	or	r16, r24
    7e98:	cf 57       	subi	r28, 0x7F	; 127
    7e9a:	df 4f       	sbci	r29, 0xFF	; 255
    7e9c:	19 83       	std	Y+1, r17	; 0x01
    7e9e:	08 83       	st	Y, r16
    7ea0:	c1 58       	subi	r28, 0x81	; 129
    7ea2:	d0 40       	sbci	r29, 0x00	; 0

static void leaveBootloader(uint16_t &application_start)
    __attribute__((__noreturn__));
static inline void leaveBootloader(uint16_t &application_start) {
  // hold my beer and watch this!
  reinterpret_cast<void (*)(void)>(application_start)();
    7ea4:	cf 57       	subi	r28, 0x7F	; 127
    7ea6:	df 4f       	sbci	r29, 0xFF	; 255
    7ea8:	e8 81       	ld	r30, Y
    7eaa:	f9 81       	ldd	r31, Y+1	; 0x01
    7eac:	c1 58       	subi	r28, 0x81	; 129
    7eae:	d0 40       	sbci	r29, 0x00	; 0
    7eb0:	09 95       	icall
    7eb2:	ff cf       	rjmp	.-2      	; 0x7eb2 <main+0xa6>

  uint32_t i2c_application_timestamp;
  uint16_t application_start = 0;

  if (isReflashNecessary(i2c_application_timestamp) &&
      isCrcOk(source_i2c_address_for_program)) {
    7eb4:	b5 dd       	rcall	.-1174   	; 0x7a20 <_ZL7isCrcOkh.constprop.3>
  init();

  uint32_t i2c_application_timestamp;
  uint16_t application_start = 0;

  if (isReflashNecessary(i2c_application_timestamp) &&
    7eb6:	88 23       	and	r24, r24
    7eb8:	49 f3       	breq	.-46     	; 0x7e8c <main+0x80>
    7eba:	e0 e0       	ldi	r30, 0x00	; 0
    7ebc:	f8 e7       	ldi	r31, 0x78	; 120

static inline void eraseApplication() {
  uint16_t ptr = BOOTLOADER_START_ADDRESS;
  do {
    ptr -= SPM_PAGESIZE;
    boot_page_erase(ptr);
    7ebe:	83 e0       	ldi	r24, 0x03	; 3
#include "bootloader.h"

static inline void eraseApplication() {
  uint16_t ptr = BOOTLOADER_START_ADDRESS;
  do {
    ptr -= SPM_PAGESIZE;
    7ec0:	e0 58       	subi	r30, 0x80	; 128
    7ec2:	f1 09       	sbc	r31, r1
    boot_page_erase(ptr);
    7ec4:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7ec8:	e8 95       	spm
    boot_spm_busy_wait();
    7eca:	07 b6       	in	r0, 0x37	; 55
    7ecc:	00 fc       	sbrc	r0, 0
    7ece:	fd cf       	rjmp	.-6      	; 0x7eca <main+0xbe>

#include "bootloader.h"

static inline void eraseApplication() {
  uint16_t ptr = BOOTLOADER_START_ADDRESS;
  do {
    7ed0:	30 97       	sbiw	r30, 0x00	; 0
    7ed2:	b1 f7       	brne	.-20     	; 0x7ec0 <main+0xb4>
    ptr -= SPM_PAGESIZE;
    boot_page_erase(ptr);
    boot_spm_busy_wait();
  } while (ptr);
  wdt_reset();
    7ed4:	a8 95       	wdr
static inline uint16_t getDataStartAddressInSource(const uint8_t i2c_address) {
  return application_byte_offset;
}

static inline uint16_t getDataLength(const uint8_t i2c_address) {
  return getWordFromSource(i2c_address, application_length_byte_offset);
    7ed6:	80 e2       	ldi	r24, 0x20	; 32
    7ed8:	90 e0       	ldi	r25, 0x00	; 0
    7eda:	89 dd       	rcall	.-1262   	; 0x79ee <_ZL17getWordFromSourcehj.constprop.5>
    7edc:	5c 01       	movw	r10, r24
  uint16_t start_address = getDataStartAddressInSource(i2c_address);
  uint16_t length = getDataLength(i2c_address);
  uint8_t buf[SPM_PAGESIZE];
  uint8_t writes = 0;

  for (uint16_t pos = 0; pos < length; pos += 2) {
    7ede:	00 e0       	ldi	r16, 0x00	; 0
    7ee0:	10 e0       	ldi	r17, 0x00	; 0
static inline void writeFlashFromI2C(const uint8_t i2c_address,
                                     uint16_t &application_start) {
  uint16_t start_address = getDataStartAddressInSource(i2c_address);
  uint16_t length = getDataLength(i2c_address);
  uint8_t buf[SPM_PAGESIZE];
  uint8_t writes = 0;
    7ee2:	81 2c       	mov	r8, r1
    7ee4:	ce 01       	movw	r24, r28
    7ee6:	01 96       	adiw	r24, 0x01	; 1
    7ee8:	7c 01       	movw	r14, r24

  for (uint16_t pos = 0; pos < length; pos += 2) {
    if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
      writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
      LED_TOGGLE();
    7eea:	99 24       	eor	r9, r9
    7eec:	93 94       	inc	r9
  uint16_t start_address = getDataStartAddressInSource(i2c_address);
  uint16_t length = getDataLength(i2c_address);
  uint8_t buf[SPM_PAGESIZE];
  uint8_t writes = 0;

  for (uint16_t pos = 0; pos < length; pos += 2) {
    7eee:	0a 15       	cp	r16, r10
    7ef0:	1b 05       	cpc	r17, r11
    7ef2:	40 f5       	brcc	.+80     	; 0x7f44 <main+0x138>
    7ef4:	68 01       	movw	r12, r16
    7ef6:	e8 94       	clt
    7ef8:	c7 f8       	bld	r12, 7
    7efa:	dd 24       	eor	r13, r13
    if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
    7efc:	01 15       	cp	r16, r1
    7efe:	11 05       	cpc	r17, r1
    7f00:	81 f0       	breq	.+32     	; 0x7f22 <main+0x116>
    7f02:	c1 14       	cp	r12, r1
    7f04:	d1 04       	cpc	r13, r1
    7f06:	69 f4       	brne	.+26     	; 0x7f22 <main+0x116>
      writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
    7f08:	ae 01       	movw	r20, r28
    7f0a:	4f 57       	subi	r20, 0x7F	; 127
    7f0c:	5f 4f       	sbci	r21, 0xFF	; 255
    7f0e:	b7 01       	movw	r22, r14
    7f10:	20 e8       	ldi	r18, 0x80	; 128
    7f12:	82 9e       	mul	r8, r18
    7f14:	c0 01       	movw	r24, r0
    7f16:	11 24       	eor	r1, r1
    7f18:	b0 dc       	rcall	.-1696   	; 0x787a <_ZL12writeToFlashjPhRj>
      LED_TOGGLE();
    7f1a:	85 b1       	in	r24, 0x05	; 5
    7f1c:	89 25       	eor	r24, r9
    7f1e:	85 b9       	out	0x05, r24	; 5
      ++writes;
    7f20:	83 94       	inc	r8
    }
    uint16_t data = getWordFromSource(i2c_address, pos + start_address);
    7f22:	c8 01       	movw	r24, r16
    7f24:	82 96       	adiw	r24, 0x22	; 34
    7f26:	63 dd       	rcall	.-1338   	; 0x79ee <_ZL17getWordFromSourcehj.constprop.5>
    buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
    7f28:	f7 01       	movw	r30, r14
    7f2a:	ec 0d       	add	r30, r12
    7f2c:	fd 1d       	adc	r31, r13
    7f2e:	90 83       	st	Z, r25
    7f30:	f8 01       	movw	r30, r16
    7f32:	31 96       	adiw	r30, 0x01	; 1
    buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
    7f34:	ef 77       	andi	r30, 0x7F	; 127
    7f36:	ff 27       	eor	r31, r31
    7f38:	ee 0d       	add	r30, r14
    7f3a:	ff 1d       	adc	r31, r15
    7f3c:	80 83       	st	Z, r24
  uint16_t start_address = getDataStartAddressInSource(i2c_address);
  uint16_t length = getDataLength(i2c_address);
  uint8_t buf[SPM_PAGESIZE];
  uint8_t writes = 0;

  for (uint16_t pos = 0; pos < length; pos += 2) {
    7f3e:	0e 5f       	subi	r16, 0xFE	; 254
    7f40:	1f 4f       	sbci	r17, 0xFF	; 255
    7f42:	d5 cf       	rjmp	.-86     	; 0x7eee <main+0xe2>
    buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
    buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
  }

  for (uint16_t pos = SPM_PAGESIZE -
                      (static_cast<uint16_t>(writes + 1) *
    7f44:	28 2d       	mov	r18, r8
    7f46:	30 e0       	ldi	r19, 0x00	; 0
    7f48:	c9 01       	movw	r24, r18
    7f4a:	01 96       	adiw	r24, 0x01	; 1
    7f4c:	96 95       	lsr	r25
    7f4e:	98 2f       	mov	r25, r24
    7f50:	88 27       	eor	r24, r24
    7f52:	97 95       	ror	r25
    7f54:	87 95       	ror	r24
                       static_cast<uint16_t>(SPM_PAGESIZE)) %
    7f56:	b5 01       	movw	r22, r10
    7f58:	1e d0       	rcall	.+60     	; 0x7f96 <__udivmodhi4>
                          length;
    7f5a:	f7 01       	movw	r30, r14
    7f5c:	e8 1b       	sub	r30, r24
    7f5e:	f9 0b       	sbc	r31, r25
    7f60:	e0 58       	subi	r30, 0x80	; 128
    7f62:	ff 4f       	sbci	r31, 0xFF	; 255
       pos < SPM_PAGESIZE; ++pos) {
    buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
    7f64:	4f ef       	ldi	r20, 0xFF	; 255
    7f66:	cf 01       	movw	r24, r30
    7f68:	8e 19       	sub	r24, r14
    7f6a:	9f 09       	sbc	r25, r15
    uint16_t data = getWordFromSource(i2c_address, pos + start_address);
    buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
    buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
  }

  for (uint16_t pos = SPM_PAGESIZE -
    7f6c:	80 38       	cpi	r24, 0x80	; 128
    7f6e:	91 05       	cpc	r25, r1
    7f70:	10 f4       	brcc	.+4      	; 0x7f76 <main+0x16a>
                      (static_cast<uint16_t>(writes + 1) *
                       static_cast<uint16_t>(SPM_PAGESIZE)) %
                          length;
       pos < SPM_PAGESIZE; ++pos) {
    buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
    7f72:	41 93       	st	Z+, r20
    7f74:	f8 cf       	rjmp	.-16     	; 0x7f66 <main+0x15a>
                     // this page and have value from previous page
  }

  writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
    7f76:	ae 01       	movw	r20, r28
    7f78:	4f 57       	subi	r20, 0x7F	; 127
    7f7a:	5f 4f       	sbci	r21, 0xFF	; 255
    7f7c:	b7 01       	movw	r22, r14
    7f7e:	c9 01       	movw	r24, r18
    7f80:	96 95       	lsr	r25
    7f82:	98 2f       	mov	r25, r24
    7f84:	88 27       	eor	r24, r24
    7f86:	97 95       	ror	r25
    7f88:	87 95       	ror	r24
    7f8a:	77 dc       	rcall	.-1810   	; 0x787a <_ZL12writeToFlashjPhRj>
  LED_OFF();
    7f8c:	28 9a       	sbi	0x05, 0	; 5

  if (isReflashNecessary(i2c_application_timestamp) &&
      isCrcOk(source_i2c_address_for_program)) {
    eraseApplication();
    writeFlashFromI2C(source_i2c_address_for_program, application_start);
    writeLatestApplicationTimestampToInternalEeprom(i2c_application_timestamp);
    7f8e:	c3 01       	movw	r24, r6
    7f90:	b2 01       	movw	r22, r4
    7f92:	bf dc       	rcall	.-1666   	; 0x7912 <_Z47writeLatestApplicationTimestampToInternalEepromm>
    7f94:	87 cf       	rjmp	.-242    	; 0x7ea4 <main+0x98>

00007f96 <__udivmodhi4>:
    7f96:	aa 1b       	sub	r26, r26
    7f98:	bb 1b       	sub	r27, r27
    7f9a:	51 e1       	ldi	r21, 0x11	; 17
    7f9c:	07 c0       	rjmp	.+14     	; 0x7fac <__udivmodhi4_ep>

00007f9e <__udivmodhi4_loop>:
    7f9e:	aa 1f       	adc	r26, r26
    7fa0:	bb 1f       	adc	r27, r27
    7fa2:	a6 17       	cp	r26, r22
    7fa4:	b7 07       	cpc	r27, r23
    7fa6:	10 f0       	brcs	.+4      	; 0x7fac <__udivmodhi4_ep>
    7fa8:	a6 1b       	sub	r26, r22
    7faa:	b7 0b       	sbc	r27, r23

00007fac <__udivmodhi4_ep>:
    7fac:	88 1f       	adc	r24, r24
    7fae:	99 1f       	adc	r25, r25
    7fb0:	5a 95       	dec	r21
    7fb2:	a9 f7       	brne	.-22     	; 0x7f9e <__udivmodhi4_loop>
    7fb4:	80 95       	com	r24
    7fb6:	90 95       	com	r25
    7fb8:	bc 01       	movw	r22, r24
    7fba:	cd 01       	movw	r24, r26
    7fbc:	08 95       	ret

00007fbe <eeprom_read_byte>:
    7fbe:	f9 99       	sbic	0x1f, 1	; 31
    7fc0:	fe cf       	rjmp	.-4      	; 0x7fbe <eeprom_read_byte>
    7fc2:	92 bd       	out	0x22, r25	; 34
    7fc4:	81 bd       	out	0x21, r24	; 33
    7fc6:	f8 9a       	sbi	0x1f, 0	; 31
    7fc8:	99 27       	eor	r25, r25
    7fca:	80 b5       	in	r24, 0x20	; 32
    7fcc:	08 95       	ret

00007fce <eeprom_write_byte>:
    7fce:	26 2f       	mov	r18, r22

00007fd0 <eeprom_write_r18>:
    7fd0:	f9 99       	sbic	0x1f, 1	; 31
    7fd2:	fe cf       	rjmp	.-4      	; 0x7fd0 <eeprom_write_r18>
    7fd4:	1f ba       	out	0x1f, r1	; 31
    7fd6:	92 bd       	out	0x22, r25	; 34
    7fd8:	81 bd       	out	0x21, r24	; 33
    7fda:	20 bd       	out	0x20, r18	; 32
    7fdc:	0f b6       	in	r0, 0x3f	; 63
    7fde:	f8 94       	cli
    7fe0:	fa 9a       	sbi	0x1f, 2	; 31
    7fe2:	f9 9a       	sbi	0x1f, 1	; 31
    7fe4:	0f be       	out	0x3f, r0	; 63
    7fe6:	01 96       	adiw	r24, 0x01	; 1
    7fe8:	08 95       	ret

00007fea <_exit>:
    7fea:	f8 94       	cli

00007fec <__stop_program>:
    7fec:	ff cf       	rjmp	.-2      	; 0x7fec <__stop_program>
