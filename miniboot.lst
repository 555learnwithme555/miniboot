   1               		.file	"miniboot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	_ZL12writeToFlashjPhRj:
  12               	.LFB18:
  13               		.file 1 "miniboot.c"
   1:miniboot.c    **** //
   2:miniboot.c    **** //  Fuses :     Ext: 0xFF, Hi: 0xD8, Lo: 0xE2
   3:miniboot.c    **** //
   4:miniboot.c    **** 
   5:miniboot.c    **** #include "Drivers/CRC/crc32.h"
   6:miniboot.c    **** #include "bootloader.h"
   7:miniboot.c    **** #include "eeprom.h"
   8:miniboot.c    **** #include "flash.h"
   9:miniboot.c    **** #include "i2c_communication.h"
  10:miniboot.c    **** #include "init.h"
  11:miniboot.c    **** 
  12:miniboot.c    **** static inline uint16_t getDataStartAddressInSource(const uint8_t i2c_address) {
  13:miniboot.c    ****   return application_byte_offset;
  14:miniboot.c    **** }
  15:miniboot.c    **** 
  16:miniboot.c    **** static inline uint16_t getDataLength(const uint8_t i2c_address) {
  17:miniboot.c    ****   return getWordFromSource(i2c_address, application_length_byte_offset);
  18:miniboot.c    **** }
  19:miniboot.c    **** 
  20:miniboot.c    **** static inline void writeToFlash(const uint16_t address, uint8_t *data,
  21:miniboot.c    ****                                 uint16_t &application_start) {
  14               		.loc 1 21 0
  15               		.cfi_startproc
  16               	.LVL0:
  17 0000 CF93      		push r28
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 28, -2
  21 0002 DF93      		push r29
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 29, -3
  25               	/* prologue: function */
  26               	/* frame size = 0 */
  27               	/* stack size = 2 */
  28               	.L__stack_usage = 2
  29 0004 DB01      		movw r26,r22
  22:miniboot.c    **** 
  23:miniboot.c    ****   if (0 == address) {
  30               		.loc 1 23 0
  31 0006 0097      		sbiw r24,0
  32 0008 01F4      		brne .L2
  24:miniboot.c    ****     application_start = static_cast<uint8_t>(
  25:miniboot.c    ****         static_cast<uint16_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS] << 8));
  33               		.loc 1 25 0
  34 000a FA01      		movw r30,r20
  35 000c 1182      		std Z+1,__zero_reg__
  36 000e 1082      		st Z,__zero_reg__
  26:miniboot.c    ****     application_start |=
  27:miniboot.c    ****         static_cast<uint8_t>(data[RESET_VECTOR_ARGUMENT_ADDRESS + 1]);
  37               		.loc 1 27 0
  38 0010 1396      		adiw r26,3
  39 0012 2C91      		ld r18,X
  40 0014 1397      		sbiw r26,3
  41 0016 30E0      		ldi r19,0
  42 0018 3183      		std Z+1,r19
  43 001a 2083      		st Z,r18
  28:miniboot.c    **** 
  29:miniboot.c    ****     data[RESET_VECTOR] = static_cast<uint8_t>(jmp_instruction);
  44               		.loc 1 29 0
  45 001c 2CE0      		ldi r18,lo8(12)
  46 001e 2C93      		st X,r18
  30:miniboot.c    ****     data[RESET_VECTOR + 1] = static_cast<uint8_t>(jmp_instruction >> 8);
  47               		.loc 1 30 0
  48 0020 24E9      		ldi r18,lo8(-108)
  49 0022 1196      		adiw r26,1
  50 0024 2C93      		st X,r18
  51 0026 1197      		sbiw r26,1
  31:miniboot.c    **** 
  32:miniboot.c    ****     data[RESET_VECTOR_ARGUMENT_ADDRESS] = static_cast<uint8_t>(
  33:miniboot.c    ****         static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2);
  52               		.loc 1 33 0
  53 0028 1296      		adiw r26,2
  54 002a 1C92      		st X,__zero_reg__
  55 002c 1297      		sbiw r26,2
  34:miniboot.c    ****     data[RESET_VECTOR_ARGUMENT_ADDRESS + 1] = static_cast<uint8_t>(
  35:miniboot.c    ****         (static_cast<uint16_t>(BOOTLOADER_START_ADDRESS) / 2) >> 8);
  56               		.loc 1 35 0
  57 002e 2CE3      		ldi r18,lo8(60)
  58 0030 1396      		adiw r26,3
  59 0032 2C93      		st X,r18
  60 0034 1397      		sbiw r26,3
  61               	.L2:
  62               	.LVL1:
  63               	.LBB31:
  64               	.LBB32:
  65               	.LBB33:
  66               		.file 2 "flash.h"
   1:flash.h       **** #pragma once
   2:flash.h       **** 
   3:flash.h       **** #include <avr/boot.h>
   4:flash.h       **** #include <avr/wdt.h>
   5:flash.h       **** 
   6:flash.h       **** #include "bootloader.h"
   7:flash.h       **** 
   8:flash.h       **** static inline void eraseApplication() {
   9:flash.h       ****   uint16_t ptr = BOOTLOADER_START_ADDRESS;
  10:flash.h       ****   do {
  11:flash.h       ****     ptr -= SPM_PAGESIZE;
  12:flash.h       ****     boot_page_erase(ptr);
  13:flash.h       ****     boot_spm_busy_wait();
  14:flash.h       ****   } while (ptr);
  15:flash.h       ****   wdt_reset();
  16:flash.h       **** }
  17:flash.h       **** 
  18:flash.h       **** static inline void erasePage(const uint16_t address) {
  19:flash.h       ****   boot_page_erase(address);
  67               		.loc 2 19 0
  68 0036 23E0      		ldi r18,lo8(3)
  69 0038 FC01      		movw r30,r24
  70               	/* #APP */
  71               	 ;  19 "flash.h" 1
  72 003a 2093 5700 		sts 87, r18
  73 003e E895      		spm
  74               		
  75               	 ;  0 "" 2
  76               	/* #NOAPP */
  77               	.L3:
  20:flash.h       ****   boot_spm_busy_wait();
  78               		.loc 2 20 0
  79 0040 07B6      		in __tmp_reg__,0x37
  80 0042 00FC      		sbrc __tmp_reg__,0
  81 0044 00C0      		rjmp .L3
  82 0046 40E0      		ldi r20,0
  83 0048 50E0      		ldi r21,0
  84               	.LVL2:
  85               	.LBE33:
  86               	.LBE32:
  87               	.LBB34:
  88               	.LBB35:
  21:flash.h       **** }
  22:flash.h       **** 
  23:flash.h       **** static inline void writeToPageBuffer(const uint16_t address, uint8_t *data) {
  24:flash.h       ****   erasePage(address);
  25:flash.h       ****   for (uint8_t i = 0; i < SPM_PAGESIZE; i += 2) {
  26:flash.h       ****     uint16_t w = *data++;
  27:flash.h       ****     w += (*data++) << 8;
  28:flash.h       ****     boot_page_fill(address + i, w);
  89               		.loc 2 28 0
  90 004a 61E0      		ldi r22,lo8(1)
  91               	.LVL3:
  92               	.L4:
  26:flash.h       ****     w += (*data++) << 8;
  93               		.loc 2 26 0
  94 004c 7C91      		ld r23,X
  95               	.LVL4:
  96 004e 1296      		adiw r26,2
  97               	.LVL5:
  98 0050 FA01      		movw r30,r20
  99 0052 E80F      		add r30,r24
 100 0054 F91F      		adc r31,r25
 101 0056 ED01      		movw r28,r26
 102 0058 2197      		sbiw r28,1
 103               	.LVL6:
  27:flash.h       ****     boot_page_fill(address + i, w);
 104               		.loc 2 27 0
 105 005a 2881      		ld r18,Y
 106 005c 30E0      		ldi r19,0
 107 005e 322F      		mov r19,r18
 108 0060 2227      		clr r18
 109               	.LVL7:
 110 0062 270F      		add r18,r23
 111 0064 311D      		adc r19,__zero_reg__
 112               		.loc 2 28 0
 113               	/* #APP */
 114               	 ;  28 "flash.h" 1
 115 0066 0901      		movw  r0, r18
 116 0068 6093 5700 		sts 87, r22
 117 006c E895      		spm
 118 006e 1124      		clr  r1
 119               		
 120               	 ;  0 "" 2
 121               	.LVL8:
 122               	/* #NOAPP */
 123 0070 4E5F      		subi r20,-2
 124 0072 5F4F      		sbci r21,-1
 125               	.LVL9:
 126               	.LBE35:
  25:flash.h       ****     uint16_t w = *data++;
 127               		.loc 2 25 0
 128 0074 4038      		cpi r20,-128
 129 0076 5105      		cpc r21,__zero_reg__
 130 0078 01F4      		brne .L4
 131               	.LVL10:
 132               	.LBE34:
 133               	.LBE31:
 134               	.LBB36:
 135               	.LBB37:
  29:flash.h       ****   }
  30:flash.h       **** }
  31:flash.h       **** 
  32:flash.h       **** static inline void writePageBufferToFlash(const uint16_t address) {
  33:flash.h       ****   boot_page_write(address);
 136               		.loc 2 33 0
 137 007a 25E0      		ldi r18,lo8(5)
 138 007c FC01      		movw r30,r24
 139               	/* #APP */
 140               	 ;  33 "flash.h" 1
 141 007e 2093 5700 		sts 87, r18
 142 0082 E895      		spm
 143               		
 144               	 ;  0 "" 2
 145               	/* #NOAPP */
 146               	.L5:
  34:flash.h       ****   boot_spm_busy_wait();
 147               		.loc 2 34 0
 148 0084 07B6      		in __tmp_reg__,0x37
 149 0086 00FC      		sbrc __tmp_reg__,0
 150 0088 00C0      		rjmp .L5
  35:flash.h       ****   boot_rww_enable();
 151               		.loc 2 35 0
 152 008a 81E1      		ldi r24,lo8(17)
 153               	.LVL11:
 154               	/* #APP */
 155               	 ;  35 "flash.h" 1
 156 008c 8093 5700 		sts 87, r24
 157 0090 E895      		spm
 158               		
 159               	 ;  0 "" 2
 160               	/* epilogue start */
 161               	/* #NOAPP */
 162               	.LBE37:
 163               	.LBE36:
  36:miniboot.c    ****   }
  37:miniboot.c    **** 
  38:miniboot.c    ****   writeToPageBuffer(address, data);
  39:miniboot.c    ****   writePageBufferToFlash(address);
  40:miniboot.c    **** }
 164               		.loc 1 40 0
 165 0092 DF91      		pop r29
 166 0094 CF91      		pop r28
 167 0096 0895      		ret
 168               		.cfi_endproc
 169               	.LFE18:
 171               	.global	_Z47writeLatestApplicationTimestampToInternalEepromm
 173               	_Z47writeLatestApplicationTimestampToInternalEepromm:
 174               	.LFB3:
 175               		.file 3 "eeprom.h"
   1:eeprom.h      **** #pragma once
   2:eeprom.h      **** 
   3:eeprom.h      **** #include "bootloader.h"
   4:eeprom.h      **** #include <avr/boot.h>
   5:eeprom.h      **** #include <avr/eeprom.h>
   6:eeprom.h      **** 
   7:eeprom.h      **** #if 0
   8:eeprom.h      **** void writeToInternalEeprom(const uint16_t data){
   9:eeprom.h      ****   eeprom_write_byte (reinterpret_cast<uint8_t
  10:eeprom.h      **** *>(EEPROM_CONFIGURATION_START_BYTE+4),data>>8);
  11:eeprom.h      ****   eeprom_write_byte (reinterpret_cast<uint8_t
  12:eeprom.h      **** *>(EEPROM_CONFIGURATION_START_BYTE+5),data);
  13:eeprom.h      ****   boot_spm_busy_wait();
  14:eeprom.h      **** }
  15:eeprom.h      **** 
  16:eeprom.h      **** void writeToInternalEeprom(const uint32_t data) {
  17:eeprom.h      ****   eeprom_write_byte(
  18:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 4),
  19:eeprom.h      ****       data >> 24);
  20:eeprom.h      ****   eeprom_write_byte(
  21:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 5),
  22:eeprom.h      ****       data >> 16);
  23:eeprom.h      ****   eeprom_write_byte(
  24:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 6),
  25:eeprom.h      ****       data >> 8);
  26:eeprom.h      ****   eeprom_write_byte(
  27:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 7), data);
  28:eeprom.h      ****   boot_spm_busy_wait();
  29:eeprom.h      **** }
  30:eeprom.h      **** #endif // #if 0
  31:eeprom.h      **** 
  32:eeprom.h      **** void writeLatestApplicationTimestampToInternalEeprom(
  33:eeprom.h      ****     const uint32_t latest_timestamp) {
 176               		.loc 3 33 0
 177               		.cfi_startproc
 178               	.LVL12:
 179 0098 CF92      		push r12
 180               	.LCFI2:
 181               		.cfi_def_cfa_offset 3
 182               		.cfi_offset 12, -2
 183 009a DF92      		push r13
 184               	.LCFI3:
 185               		.cfi_def_cfa_offset 4
 186               		.cfi_offset 13, -3
 187 009c EF92      		push r14
 188               	.LCFI4:
 189               		.cfi_def_cfa_offset 5
 190               		.cfi_offset 14, -4
 191 009e FF92      		push r15
 192               	.LCFI5:
 193               		.cfi_def_cfa_offset 6
 194               		.cfi_offset 15, -5
 195               	/* prologue: function */
 196               	/* frame size = 0 */
 197               	/* stack size = 4 */
 198               	.L__stack_usage = 4
 199 00a0 6B01      		movw r12,r22
 200 00a2 7C01      		movw r14,r24
  34:eeprom.h      ****   eeprom_write_byte(
  35:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE),
  36:eeprom.h      ****       latest_timestamp >> 24);
 201               		.loc 3 36 0
 202 00a4 6F2D      		mov r22,r15
 203 00a6 7727      		clr r23
 204 00a8 8827      		clr r24
 205 00aa 9927      		clr r25
 206               	.LVL13:
 207 00ac 86EF      		ldi r24,lo8(-10)
 208 00ae 93E0      		ldi r25,lo8(3)
 209 00b0 0E94 0000 		call eeprom_write_byte
 210               	.LVL14:
  37:eeprom.h      ****   eeprom_write_byte(
  38:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 1),
  39:eeprom.h      ****       latest_timestamp >> 16);
 211               		.loc 3 39 0
 212 00b4 B701      		movw r22,r14
 213 00b6 8827      		clr r24
 214 00b8 9927      		clr r25
 215 00ba 87EF      		ldi r24,lo8(-9)
 216 00bc 93E0      		ldi r25,lo8(3)
 217 00be 0E94 0000 		call eeprom_write_byte
 218               	.LVL15:
  40:eeprom.h      ****   eeprom_write_byte(
  41:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 2),
  42:eeprom.h      ****       latest_timestamp >> 8);
 219               		.loc 3 42 0
 220 00c2 9927      		clr r25
 221 00c4 8F2D      		mov r24,r15
 222 00c6 7E2D      		mov r23,r14
 223 00c8 6D2D      		mov r22,r13
 224 00ca 88EF      		ldi r24,lo8(-8)
 225 00cc 93E0      		ldi r25,lo8(3)
 226 00ce 0E94 0000 		call eeprom_write_byte
 227               	.LVL16:
  43:eeprom.h      ****   eeprom_write_byte(
  44:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 3),
  45:eeprom.h      ****       latest_timestamp);
 228               		.loc 3 45 0
 229 00d2 6C2D      		mov r22,r12
 230 00d4 89EF      		ldi r24,lo8(-7)
 231 00d6 93E0      		ldi r25,lo8(3)
 232 00d8 0E94 0000 		call eeprom_write_byte
 233               	.LVL17:
 234               	.L11:
  46:eeprom.h      ****   boot_spm_busy_wait();
 235               		.loc 3 46 0 discriminator 1
 236 00dc 07B6      		in __tmp_reg__,0x37
 237 00de 00FC      		sbrc __tmp_reg__,0
 238 00e0 00C0      		rjmp .L11
 239               	/* epilogue start */
  47:eeprom.h      **** }
 240               		.loc 3 47 0
 241 00e2 FF90      		pop r15
 242 00e4 EF90      		pop r14
 243 00e6 DF90      		pop r13
 244 00e8 CF90      		pop r12
 245               	.LVL18:
 246 00ea 0895      		ret
 247               		.cfi_endproc
 248               	.LFE3:
 250               	.global	_Z48readLatestApplicationTimestampFromInternalEepromv
 252               	_Z48readLatestApplicationTimestampFromInternalEepromv:
 253               	.LFB4:
  48:eeprom.h      **** 
  49:eeprom.h      **** uint32_t readLatestApplicationTimestampFromInternalEeprom() {
 254               		.loc 3 49 0
 255               		.cfi_startproc
 256 00ec CF92      		push r12
 257               	.LCFI6:
 258               		.cfi_def_cfa_offset 3
 259               		.cfi_offset 12, -2
 260 00ee DF92      		push r13
 261               	.LCFI7:
 262               		.cfi_def_cfa_offset 4
 263               		.cfi_offset 13, -3
 264 00f0 EF92      		push r14
 265               	.LCFI8:
 266               		.cfi_def_cfa_offset 5
 267               		.cfi_offset 14, -4
 268 00f2 FF92      		push r15
 269               	.LCFI9:
 270               		.cfi_def_cfa_offset 6
 271               		.cfi_offset 15, -5
 272 00f4 CF93      		push r28
 273               	.LCFI10:
 274               		.cfi_def_cfa_offset 7
 275               		.cfi_offset 28, -6
 276               	/* prologue: function */
 277               	/* frame size = 0 */
 278               	/* stack size = 5 */
 279               	.L__stack_usage = 5
 280               	.LBB38:
  50:eeprom.h      ****   uint32_t result =
  51:eeprom.h      ****       static_cast<uint32_t>(eeprom_read_byte(
  52:eeprom.h      ****           reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE)))
 281               		.loc 3 52 0
 282 00f6 86EF      		ldi r24,lo8(-10)
 283 00f8 93E0      		ldi r25,lo8(3)
 284 00fa 0E94 0000 		call eeprom_read_byte
 285               	.LVL19:
  53:eeprom.h      ****       << 24;
 286               		.loc 3 53 0
 287 00fe C82E      		mov r12,r24
 288 0100 D12C      		mov r13,__zero_reg__
 289 0102 E12C      		mov r14,__zero_reg__
 290 0104 F12C      		mov r15,__zero_reg__
 291 0106 FC2C      		mov r15,r12
 292 0108 EE24      		clr r14
 293 010a DD24      		clr r13
 294 010c CC24      		clr r12
 295               	.LVL20:
  54:eeprom.h      ****   result |= static_cast<uint32_t>(eeprom_read_byte(reinterpret_cast<uint8_t *>(
  55:eeprom.h      ****                 EEPROM_CONFIGURATION_START_BYTE + 1)))
 296               		.loc 3 55 0
 297 010e 87EF      		ldi r24,lo8(-9)
 298 0110 93E0      		ldi r25,lo8(3)
 299 0112 0E94 0000 		call eeprom_read_byte
 300               	.LVL21:
  56:eeprom.h      ****             << 16;
 301               		.loc 3 56 0
 302 0116 E82A      		or r14,r24
  57:eeprom.h      ****   result |= static_cast<uint32_t>(eeprom_read_byte(reinterpret_cast<uint8_t *>(
  58:eeprom.h      ****                 EEPROM_CONFIGURATION_START_BYTE + 2)))
 303               		.loc 3 58 0
 304 0118 88EF      		ldi r24,lo8(-8)
 305 011a 93E0      		ldi r25,lo8(3)
 306 011c 0E94 0000 		call eeprom_read_byte
 307               	.LVL22:
 308 0120 C82F      		mov r28,r24
 309               	.LVL23:
  59:eeprom.h      ****             << 8;
  60:eeprom.h      ****   result |= static_cast<uint32_t>(eeprom_read_byte(
  61:eeprom.h      ****       reinterpret_cast<uint8_t *>(EEPROM_CONFIGURATION_START_BYTE + 3)));
 310               		.loc 3 61 0
 311 0122 89EF      		ldi r24,lo8(-7)
 312 0124 93E0      		ldi r25,lo8(3)
 313               	.LVL24:
 314 0126 0E94 0000 		call eeprom_read_byte
 315               	.LVL25:
 316 012a A701      		movw r20,r14
 317 012c 9601      		movw r18,r12
 318 012e 282B      		or r18,r24
 319 0130 DA01      		movw r26,r20
 320 0132 C901      		movw r24,r18
 321 0134 BC01      		movw r22,r24
 322 0136 CD01      		movw r24,r26
 323 0138 7C2B      		or r23,r28
 324               	.LVL26:
 325               	.L14:
  62:eeprom.h      ****   boot_spm_busy_wait();
 326               		.loc 3 62 0 discriminator 1
 327 013a 07B6      		in __tmp_reg__,0x37
 328 013c 00FC      		sbrc __tmp_reg__,0
 329 013e 00C0      		rjmp .L14
 330               	/* epilogue start */
 331               	.LBE38:
  63:eeprom.h      ****   return result;
  64:eeprom.h      **** }
 332               		.loc 3 64 0
 333 0140 CF91      		pop r28
 334 0142 FF90      		pop r15
 335 0144 EF90      		pop r14
 336 0146 DF90      		pop r13
 337 0148 CF90      		pop r12
 338 014a 0895      		ret
 339               		.cfi_endproc
 340               	.LFE4:
 342               	.global	_Z8readBytehj
 344               	_Z8readBytehj:
 345               	.LFB11:
 346               		.file 4 "i2c_communication.h"
   1:i2c_communication.h **** #pragma once
   2:i2c_communication.h **** 
   3:i2c_communication.h **** #include "I2C-master-lib/i2c_master.h"
   4:i2c_communication.h **** 
   5:i2c_communication.h **** uint8_t readByte(const uint8_t source_address,
   6:i2c_communication.h ****                  const uint16_t register_address) {
 347               		.loc 4 6 0
 348               		.cfi_startproc
 349               	.LVL27:
 350 014c 1F93      		push r17
 351               	.LCFI11:
 352               		.cfi_def_cfa_offset 3
 353               		.cfi_offset 17, -2
 354 014e CF93      		push r28
 355               	.LCFI12:
 356               		.cfi_def_cfa_offset 4
 357               		.cfi_offset 28, -3
 358 0150 DF93      		push r29
 359               	.LCFI13:
 360               		.cfi_def_cfa_offset 5
 361               		.cfi_offset 29, -4
 362 0152 00D0      		rcall .
 363               	.LCFI14:
 364               		.cfi_def_cfa_offset 7
 365 0154 CDB7      		in r28,__SP_L__
 366 0156 DEB7      		in r29,__SP_H__
 367               	.LCFI15:
 368               		.cfi_def_cfa_register 28
 369               	/* prologue: function */
 370               	/* frame size = 2 */
 371               	/* stack size = 5 */
 372               	.L__stack_usage = 5
 373               	.LVL28:
 374               	.LBB39:
   7:i2c_communication.h ****   uint8_t data = 0xFF;
   8:i2c_communication.h ****   uint8_t write_source_address = source_address << 1;
 375               		.loc 4 8 0
 376 0158 182F      		mov r17,r24
 377 015a 110F      		lsl r17
 378               	.LVL29:
   9:i2c_communication.h ****   i2c_start(write_source_address);
 379               		.loc 4 9 0
 380 015c 812F      		mov r24,r17
 381               	.LVL30:
 382 015e 6A83      		std Y+2,r22
 383 0160 7983      		std Y+1,r23
 384 0162 0E94 0000 		call _Z9i2c_starth
 385               	.LVL31:
  10:i2c_communication.h ****   i2c_write(register_address >> 8);
 386               		.loc 4 10 0
 387 0166 7981      		ldd r23,Y+1
 388 0168 872F      		mov r24,r23
 389 016a 0E94 0000 		call _Z9i2c_writeh
 390               	.LVL32:
  11:i2c_communication.h ****   i2c_write(register_address);
 391               		.loc 4 11 0
 392 016e 6A81      		ldd r22,Y+2
 393 0170 862F      		mov r24,r22
 394 0172 0E94 0000 		call _Z9i2c_writeh
 395               	.LVL33:
  12:i2c_communication.h ****   i2c_stop();
 396               		.loc 4 12 0
 397 0176 0E94 0000 		call _Z8i2c_stopv
 398               	.LVL34:
  13:i2c_communication.h **** 
  14:i2c_communication.h ****   uint8_t read_source_address = write_source_address | 0x01;
  15:i2c_communication.h ****   i2c_start(read_source_address);
 399               		.loc 4 15 0
 400 017a 812F      		mov r24,r17
 401 017c 8160      		ori r24,lo8(1)
 402               	.LVL35:
 403 017e 0E94 0000 		call _Z9i2c_starth
 404               	.LVL36:
 405               	/* epilogue start */
 406               	.LBE39:
  16:i2c_communication.h ****   data = i2c_read_ack();
  17:i2c_communication.h **** 
  18:i2c_communication.h ****   return data;
  19:i2c_communication.h **** }
 407               		.loc 4 19 0
 408 0182 0F90      		pop __tmp_reg__
 409 0184 0F90      		pop __tmp_reg__
 410 0186 DF91      		pop r29
 411 0188 CF91      		pop r28
 412 018a 1F91      		pop r17
 413               	.LVL37:
 414               	.LBB40:
  16:i2c_communication.h ****   data = i2c_read_ack();
 415               		.loc 4 16 0
 416 018c 0C94 0000 		jmp _Z12i2c_read_ackv
 417               	.LVL38:
 418               	.LBE40:
 419               		.cfi_endproc
 420               	.LFE11:
 423               	_ZL17getWordFromSourcehj.constprop.5:
 424               	.LFB27:
  20:i2c_communication.h **** 
  21:i2c_communication.h **** static uint16_t getWordFromSource(const uint8_t i2c_address,
 425               		.loc 4 21 0
 426               		.cfi_startproc
 427               	.LVL39:
 428 0190 0F93      		push r16
 429               	.LCFI16:
 430               		.cfi_def_cfa_offset 3
 431               		.cfi_offset 16, -2
 432 0192 1F93      		push r17
 433               	.LCFI17:
 434               		.cfi_def_cfa_offset 4
 435               		.cfi_offset 17, -3
 436 0194 CF93      		push r28
 437               	.LCFI18:
 438               		.cfi_def_cfa_offset 5
 439               		.cfi_offset 28, -4
 440 0196 DF93      		push r29
 441               	.LCFI19:
 442               		.cfi_def_cfa_offset 6
 443               		.cfi_offset 29, -5
 444               	/* prologue: function */
 445               	/* frame size = 0 */
 446               	/* stack size = 4 */
 447               	.L__stack_usage = 4
 448 0198 8C01      		movw r16,r24
 449               	.LVL40:
 450               	.LBB41:
  22:i2c_communication.h ****                                   const uint16_t data_address) {
  23:i2c_communication.h ****   uint16_t result = static_cast<uint16_t>(readByte(i2c_address, data_address))
 451               		.loc 4 23 0
 452 019a BC01      		movw r22,r24
 453 019c 80E5      		ldi r24,lo8(80)
 454               	.LVL41:
 455 019e 0E94 0000 		call _Z8readBytehj
 456               	.LVL42:
  24:i2c_communication.h ****                     << 8;
 457               		.loc 4 24 0
 458 01a2 C82F      		mov r28,r24
 459 01a4 D0E0      		ldi r29,0
 460 01a6 DC2F      		mov r29,r28
 461 01a8 CC27      		clr r28
 462               	.LVL43:
  25:i2c_communication.h ****   result |= static_cast<uint16_t>(readByte(i2c_address, data_address + 1));
 463               		.loc 4 25 0
 464 01aa B801      		movw r22,r16
 465 01ac 6F5F      		subi r22,-1
 466 01ae 7F4F      		sbci r23,-1
 467 01b0 80E5      		ldi r24,lo8(80)
 468 01b2 0E94 0000 		call _Z8readBytehj
 469               	.LVL44:
 470               	.LBE41:
  26:i2c_communication.h ****   return result;
  27:i2c_communication.h **** }
 471               		.loc 4 27 0
 472 01b6 9E01      		movw r18,r28
 473 01b8 282B      		or r18,r24
 474 01ba C901      		movw r24,r18
 475               	.LVL45:
 476               	/* epilogue start */
 477 01bc DF91      		pop r29
 478 01be CF91      		pop r28
 479 01c0 1F91      		pop r17
 480 01c2 0F91      		pop r16
 481               	.LVL46:
 482 01c4 0895      		ret
 483               		.cfi_endproc
 484               	.LFE27:
 487               	_ZL7isCrcOkh.constprop.3:
 488               	.LFB29:
  41:miniboot.c    **** 
  42:miniboot.c    **** static inline bool isCrcOk(const uint8_t i2c_address) {
 489               		.loc 1 42 0
 490               		.cfi_startproc
 491 01c6 3F92      		push r3
 492               	.LCFI20:
 493               		.cfi_def_cfa_offset 3
 494               		.cfi_offset 3, -2
 495 01c8 4F92      		push r4
 496               	.LCFI21:
 497               		.cfi_def_cfa_offset 4
 498               		.cfi_offset 4, -3
 499 01ca 5F92      		push r5
 500               	.LCFI22:
 501               		.cfi_def_cfa_offset 5
 502               		.cfi_offset 5, -4
 503 01cc 6F92      		push r6
 504               	.LCFI23:
 505               		.cfi_def_cfa_offset 6
 506               		.cfi_offset 6, -5
 507 01ce 7F92      		push r7
 508               	.LCFI24:
 509               		.cfi_def_cfa_offset 7
 510               		.cfi_offset 7, -6
 511 01d0 8F92      		push r8
 512               	.LCFI25:
 513               		.cfi_def_cfa_offset 8
 514               		.cfi_offset 8, -7
 515 01d2 9F92      		push r9
 516               	.LCFI26:
 517               		.cfi_def_cfa_offset 9
 518               		.cfi_offset 9, -8
 519 01d4 AF92      		push r10
 520               	.LCFI27:
 521               		.cfi_def_cfa_offset 10
 522               		.cfi_offset 10, -9
 523 01d6 BF92      		push r11
 524               	.LCFI28:
 525               		.cfi_def_cfa_offset 11
 526               		.cfi_offset 11, -10
 527 01d8 CF92      		push r12
 528               	.LCFI29:
 529               		.cfi_def_cfa_offset 12
 530               		.cfi_offset 12, -11
 531 01da DF92      		push r13
 532               	.LCFI30:
 533               		.cfi_def_cfa_offset 13
 534               		.cfi_offset 13, -12
 535 01dc EF92      		push r14
 536               	.LCFI31:
 537               		.cfi_def_cfa_offset 14
 538               		.cfi_offset 14, -13
 539 01de FF92      		push r15
 540               	.LCFI32:
 541               		.cfi_def_cfa_offset 15
 542               		.cfi_offset 15, -14
 543 01e0 0F93      		push r16
 544               	.LCFI33:
 545               		.cfi_def_cfa_offset 16
 546               		.cfi_offset 16, -15
 547 01e2 1F93      		push r17
 548               	.LCFI34:
 549               		.cfi_def_cfa_offset 17
 550               		.cfi_offset 17, -16
 551 01e4 CF93      		push r28
 552               	.LCFI35:
 553               		.cfi_def_cfa_offset 18
 554               		.cfi_offset 28, -17
 555 01e6 DF93      		push r29
 556               	.LCFI36:
 557               		.cfi_def_cfa_offset 19
 558               		.cfi_offset 29, -18
 559 01e8 CDB7      		in r28,__SP_L__
 560 01ea DEB7      		in r29,__SP_H__
 561               	.LCFI37:
 562               		.cfi_def_cfa_register 28
 563 01ec D450      		subi r29,4
 564               	.LCFI38:
 565               		.cfi_def_cfa_offset 1043
 566 01ee 0FB6      		in __tmp_reg__,__SREG__
 567 01f0 F894      		cli
 568 01f2 DEBF      		out __SP_H__,r29
 569 01f4 0FBE      		out __SREG__,__tmp_reg__
 570 01f6 CDBF      		out __SP_L__,r28
 571               	/* prologue: function */
 572               	/* frame size = 1024 */
 573               	/* stack size = 1041 */
 574               	.L__stack_usage = 1041
 575               	.LVL47:
 576               	.LBB57:
 577               	.LBB58:
 578               	.LBB59:
  17:miniboot.c    **** }
 579               		.loc 1 17 0
 580 01f8 80E2      		ldi r24,lo8(32)
 581 01fa 90E0      		ldi r25,0
 582 01fc 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 583               	.LVL48:
 584 0200 8C01      		movw r16,r24
 585               	.LVL49:
 586 0202 FE01      		movw r30,r28
 587 0204 3196      		adiw r30,1
 588 0206 80E0      		ldi r24,0
 589 0208 90E0      		ldi r25,0
 590 020a DC01      		movw r26,r24
 591 020c 5F01      		movw r10,r30
 592               	.LVL50:
 593               	.L21:
 594 020e AC01      		movw r20,r24
 595 0210 BD01      		movw r22,r26
 596 0212 28E0      		ldi r18,lo8(8)
 597               	.LVL51:
 598               	.L20:
 599               	.LBE59:
 600               	.LBE58:
 601               	.LBB60:
 602               	.LBB61:
 603               	.LBB62:
 604               	.LBB63:
 605               	.LBB64:
 606               		.file 5 "Drivers/CRC/crc32.h"
   1:Drivers/CRC/crc32.h **** #pragma once
   2:Drivers/CRC/crc32.h **** 
   3:Drivers/CRC/crc32.h **** #include <stdint.h>
   4:Drivers/CRC/crc32.h **** 
   5:Drivers/CRC/crc32.h **** static constexpr uint32_t polynomial_representation = 0xEDB88320UL;
   6:Drivers/CRC/crc32.h **** static constexpr uint16_t crc_table_size = 0x100;
   7:Drivers/CRC/crc32.h **** 
   8:Drivers/CRC/crc32.h **** static inline uint32_t crc32_for_byte(uint32_t r) {
   9:Drivers/CRC/crc32.h ****   for (uint8_t i = 0; i < 8; ++i) {
  10:Drivers/CRC/crc32.h ****     r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
 607               		.loc 5 10 0
 608 0214 40FD      		sbrc r20,0
 609 0216 00C0      		rjmp .L29
 610 0218 30E2      		ldi r19,lo8(32)
 611 021a C32E      		mov r12,r19
 612 021c 33E8      		ldi r19,lo8(-125)
 613 021e D32E      		mov r13,r19
 614 0220 38EB      		ldi r19,lo8(-72)
 615 0222 E32E      		mov r14,r19
 616 0224 3DEE      		ldi r19,lo8(-19)
 617 0226 F32E      		mov r15,r19
 618 0228 00C0      		rjmp .L19
 619               	.L29:
 620 022a C12C      		mov r12,__zero_reg__
 621 022c D12C      		mov r13,__zero_reg__
 622 022e 7601      		movw r14,r12
 623               	.L19:
 624 0230 7695      		lsr r23
 625 0232 6795      		ror r22
 626 0234 5795      		ror r21
 627 0236 4795      		ror r20
 628               	.LVL52:
 629 0238 4C25      		eor r20,r12
 630 023a 5D25      		eor r21,r13
 631 023c 6E25      		eor r22,r14
 632 023e 7F25      		eor r23,r15
 633               	.LVL53:
 634 0240 2150      		subi r18,lo8(-(-1))
 635               	.LVL54:
   9:Drivers/CRC/crc32.h ****     r = (r & 1 ? 0 : polynomial_representation) ^ r >> 1;
 636               		.loc 5 9 0
 637 0242 01F4      		brne .L20
 638               	.LBE64:
  11:Drivers/CRC/crc32.h ****   }
  12:Drivers/CRC/crc32.h ****   return r ^ (uint32_t)0xFF000000L;
 639               		.loc 5 12 0
 640 0244 7095      		com r23
 641               	.LVL55:
 642               	.LBE63:
 643               	.LBE62:
  13:Drivers/CRC/crc32.h **** }
  14:Drivers/CRC/crc32.h **** 
  15:Drivers/CRC/crc32.h **** static inline void init_table(uint32_t *crc_table) {
  16:Drivers/CRC/crc32.h ****   for (uint16_t i = 0; i < crc_table_size; ++i) {
  17:Drivers/CRC/crc32.h ****     crc_table[i] = crc32_for_byte(i);
 644               		.loc 5 17 0
 645 0246 4193      		st Z+,r20
 646 0248 5193      		st Z+,r21
 647 024a 6193      		st Z+,r22
 648 024c 7193      		st Z+,r23
 649               	.LVL56:
 650 024e 0196      		adiw r24,1
 651 0250 A11D      		adc r26,__zero_reg__
 652 0252 B11D      		adc r27,__zero_reg__
 653               	.LVL57:
  16:Drivers/CRC/crc32.h ****     crc_table[i] = crc32_for_byte(i);
 654               		.loc 5 16 0
 655 0254 8115      		cp r24,__zero_reg__
 656 0256 21E0      		ldi r18,1
 657 0258 9207      		cpc r25,r18
 658 025a A105      		cpc r26,__zero_reg__
 659 025c B105      		cpc r27,__zero_reg__
 660               	.LVL58:
 661 025e 01F4      		brne .L21
 662 0260 C12C      		mov r12,__zero_reg__
 663 0262 D12C      		mov r13,__zero_reg__
 664 0264 7601      		movw r14,r12
 665 0266 412C      		mov r4,__zero_reg__
 666 0268 512C      		mov r5,__zero_reg__
 667               	.LBE61:
 668               	.LBE60:
 669               	.LBB65:
  43:miniboot.c    ****   bool status = false;
  44:miniboot.c    ****   uint32_t crc = 0;
  45:miniboot.c    ****   uint16_t start_address = getDataStartAddressInSource(i2c_address);
  46:miniboot.c    ****   uint16_t length = getDataLength(i2c_address);
  47:miniboot.c    **** 
  48:miniboot.c    ****   uint32_t table[crc_table_size];
  49:miniboot.c    ****   init_table(&table[0]);
  50:miniboot.c    **** 
  51:miniboot.c    ****   for (uint16_t pos = 0; pos < length + 1;
 670               		.loc 1 51 0
 671 026a 4801      		movw r8,r16
 672 026c 8FEF      		ldi r24,-1
 673 026e 881A      		sub r8,r24
 674 0270 980A      		sbc r9,r24
 675               	.LVL59:
 676               	.LBB66:
  52:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
  53:miniboot.c    ****     if (pos >= length)
  54:miniboot.c    ****       break;
  55:miniboot.c    **** 
  56:miniboot.c    ****     uint16_t data = getWordFromSource(i2c_address, pos + start_address);
  57:miniboot.c    ****     if (pos == length - 1)
 677               		.loc 1 57 0
 678 0272 3801      		movw r6,r16
 679 0274 91E0      		ldi r25,1
 680 0276 691A      		sub r6,r25
 681 0278 7108      		sbc r7,__zero_reg__
  58:miniboot.c    ****       data &= 0xFF00;
  59:miniboot.c    **** 
  60:miniboot.c    ****     uint8_t to_little_endian[2];
  61:miniboot.c    ****     to_little_endian[0] = static_cast<uint8_t>(data >> 8);
  62:miniboot.c    ****     to_little_endian[1] = static_cast<uint8_t>(data);
  63:miniboot.c    **** 
  64:miniboot.c    ****     crc32(reinterpret_cast<const void *>(&to_little_endian[0]), 2, &table[0],
  65:miniboot.c    ****           &crc);
  66:miniboot.c    **** 
  67:miniboot.c    ****     uint8_t toggle_led_every_x_bytes = 128;
  68:miniboot.c    ****     if (0 == pos % toggle_led_every_x_bytes)
  69:miniboot.c    ****       LED_TOGGLE();
 682               		.loc 1 69 0
 683 027a 3324      		clr r3
 684 027c 3394      		inc r3
 685               	.LVL60:
 686               	.L22:
 687               	.LBE66:
  51:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
 688               		.loc 1 51 0
 689 027e 4814      		cp r4,r8
 690 0280 5904      		cpc r5,r9
 691 0282 00F4      		brsh .L26
 692               	.LBB69:
  53:miniboot.c    ****       break;
 693               		.loc 1 53 0
 694 0284 4016      		cp r4,r16
 695 0286 5106      		cpc r5,r17
 696 0288 00F4      		brsh .L26
  56:miniboot.c    ****     if (pos == length - 1)
 697               		.loc 1 56 0
 698 028a C201      		movw r24,r4
 699 028c 8296      		adiw r24,34
 700 028e 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 701               	.LVL61:
  57:miniboot.c    ****       data &= 0xFF00;
 702               		.loc 1 57 0
 703 0292 4614      		cp r4,r6
 704 0294 5704      		cpc r5,r7
 705 0296 01F4      		brne .L24
  58:miniboot.c    **** 
 706               		.loc 1 58 0
 707 0298 8827      		clr r24
 708               	.LVL62:
 709               	.L24:
 710               	.LBB67:
 711               	.LBB68:
  18:Drivers/CRC/crc32.h ****   }
  19:Drivers/CRC/crc32.h **** }
  20:Drivers/CRC/crc32.h **** 
  21:Drivers/CRC/crc32.h **** static inline void crc32(const void *data, const uint16_t length,
  22:Drivers/CRC/crc32.h ****                          const uint32_t *crc_table, uint32_t *crc) {
  23:Drivers/CRC/crc32.h ****   for (uint16_t i = 0; i < length; ++i) {
  24:Drivers/CRC/crc32.h ****     *crc = crc_table[static_cast<uint8_t>(*crc) ^ ((uint8_t *)data)[i]] ^
 712               		.loc 5 24 0
 713 029a 9C25      		eor r25,r12
  25:Drivers/CRC/crc32.h ****            *crc >> 8;
 714               		.loc 5 25 0
 715 029c CD2C      		mov r12,r13
 716 029e DE2C      		mov r13,r14
 717 02a0 EF2C      		mov r14,r15
 718 02a2 FF24      		clr r15
 719               	.LVL63:
  24:Drivers/CRC/crc32.h ****            *crc >> 8;
 720               		.loc 5 24 0
 721 02a4 F501      		movw r30,r10
 722 02a6 24E0      		ldi r18,lo8(4)
 723 02a8 929F      		mul r25,r18
 724 02aa E00D      		add r30,r0
 725 02ac F11D      		adc r31,r1
 726 02ae 1124      		clr __zero_reg__
 727 02b0 4081      		ld r20,Z
 728 02b2 5181      		ldd r21,Z+1
 729 02b4 6281      		ldd r22,Z+2
 730 02b6 7381      		ldd r23,Z+3
 731 02b8 C426      		eor r12,r20
 732 02ba D526      		eor r13,r21
 733 02bc E626      		eor r14,r22
 734 02be F726      		eor r15,r23
 735               	.LVL64:
 736 02c0 8C25      		eor r24,r12
 737               	.LVL65:
 738               		.loc 5 25 0
 739 02c2 CD2C      		mov r12,r13
 740 02c4 DE2C      		mov r13,r14
 741 02c6 EF2C      		mov r14,r15
 742 02c8 FF24      		clr r15
 743               	.LVL66:
  24:Drivers/CRC/crc32.h ****            *crc >> 8;
 744               		.loc 5 24 0
 745 02ca F501      		movw r30,r10
 746 02cc 94E0      		ldi r25,lo8(4)
 747 02ce 899F      		mul r24,r25
 748 02d0 E00D      		add r30,r0
 749 02d2 F11D      		adc r31,r1
 750 02d4 1124      		clr __zero_reg__
 751 02d6 8081      		ld r24,Z
 752 02d8 9181      		ldd r25,Z+1
 753 02da A281      		ldd r26,Z+2
 754 02dc B381      		ldd r27,Z+3
 755 02de C826      		eor r12,r24
 756 02e0 D926      		eor r13,r25
 757 02e2 EA26      		eor r14,r26
 758 02e4 FB26      		eor r15,r27
 759               	.LVL67:
 760               	.LBE68:
 761               	.LBE67:
  68:miniboot.c    ****       LED_TOGGLE();
 762               		.loc 1 68 0
 763 02e6 C201      		movw r24,r4
 764 02e8 8F77      		andi r24,127
 765 02ea 9927      		clr r25
 766 02ec 892B      		or r24,r25
 767 02ee 01F4      		brne .L25
 768               		.loc 1 69 0
 769 02f0 85B1      		in r24,0x5
 770 02f2 8325      		eor r24,r3
 771 02f4 85B9      		out 0x5,r24
 772               	.L25:
 773               	.LBE69:
  51:miniboot.c    ****        pos += 2) { // length +1 in case of odd number lengths
 774               		.loc 1 51 0
 775 02f6 22E0      		ldi r18,2
 776 02f8 420E      		add r4,r18
 777 02fa 511C      		adc r5,__zero_reg__
 778               	.LVL68:
 779 02fc 00C0      		rjmp .L22
 780               	.LVL69:
 781               	.L26:
 782               	.LBE65:
  70:miniboot.c    ****   }
  71:miniboot.c    **** 
  72:miniboot.c    ****   uint32_t expected_crc = static_cast<uint32_t>(getWordFromSource(
  73:miniboot.c    ****                               i2c_address, application_crc_expected_index))
 783               		.loc 1 73 0
 784 02fe 8CE1      		ldi r24,lo8(28)
 785 0300 90E0      		ldi r25,0
 786 0302 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 787               	.LVL70:
  74:miniboot.c    ****                           << 16;
 788               		.loc 1 74 0
 789 0306 AC01      		movw r20,r24
 790 0308 60E0      		ldi r22,0
 791 030a 70E0      		ldi r23,0
 792 030c 5A01      		movw r10,r20
 793 030e 9924      		clr r9
 794 0310 8824      		clr r8
 795               	.LVL71:
  75:miniboot.c    ****   expected_crc |= static_cast<uint32_t>(
  76:miniboot.c    ****       getWordFromSource(i2c_address, application_crc_expected_index + 2));
 796               		.loc 1 76 0
 797 0312 8EE1      		ldi r24,lo8(30)
 798 0314 90E0      		ldi r25,0
 799 0316 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 800               	.LVL72:
 801 031a 8C01      		movw r16,r24
 802 031c 20E0      		ldi r18,0
 803 031e 30E0      		ldi r19,0
 804 0320 B501      		movw r22,r10
 805 0322 A401      		movw r20,r8
 806 0324 402B      		or r20,r16
 807 0326 512B      		or r21,r17
 808 0328 622B      		or r22,r18
 809 032a 732B      		or r23,r19
  77:miniboot.c    **** 
  78:miniboot.c    ****   if (crc == expected_crc) {
 810               		.loc 1 78 0
 811 032c 81E0      		ldi r24,lo8(1)
 812               	.LVL73:
 813 032e C416      		cp r12,r20
 814 0330 D506      		cpc r13,r21
 815 0332 E606      		cpc r14,r22
 816 0334 F706      		cpc r15,r23
 817 0336 01F0      		breq .L28
 818 0338 80E0      		ldi r24,0
 819               	.L28:
 820               	/* epilogue start */
 821               	.LBE57:
  79:miniboot.c    ****     status = true;
  80:miniboot.c    ****   }
  81:miniboot.c    ****   return status;
  82:miniboot.c    **** }
 822               		.loc 1 82 0
 823 033a DC5F      		subi r29,-4
 824 033c 0FB6      		in __tmp_reg__,__SREG__
 825 033e F894      		cli
 826 0340 DEBF      		out __SP_H__,r29
 827 0342 0FBE      		out __SREG__,__tmp_reg__
 828 0344 CDBF      		out __SP_L__,r28
 829 0346 DF91      		pop r29
 830 0348 CF91      		pop r28
 831 034a 1F91      		pop r17
 832 034c 0F91      		pop r16
 833               	.LVL74:
 834 034e FF90      		pop r15
 835 0350 EF90      		pop r14
 836 0352 DF90      		pop r13
 837 0354 CF90      		pop r12
 838               	.LVL75:
 839 0356 BF90      		pop r11
 840 0358 AF90      		pop r10
 841 035a 9F90      		pop r9
 842 035c 8F90      		pop r8
 843 035e 7F90      		pop r7
 844 0360 6F90      		pop r6
 845 0362 5F90      		pop r5
 846 0364 4F90      		pop r4
 847               	.LVL76:
 848 0366 3F90      		pop r3
 849 0368 0895      		ret
 850               		.cfi_endproc
 851               	.LFE29:
 853               		.section	.text.startup,"ax",@progbits
 854               	.global	main
 856               	main:
 857               	.LFB23:
  83:miniboot.c    **** 
  84:miniboot.c    **** static inline void writeFlashFromI2C(const uint8_t i2c_address,
  85:miniboot.c    ****                                      uint16_t &application_start) {
  86:miniboot.c    ****   uint16_t start_address = getDataStartAddressInSource(i2c_address);
  87:miniboot.c    ****   uint16_t length = getDataLength(i2c_address);
  88:miniboot.c    ****   uint8_t buf[SPM_PAGESIZE];
  89:miniboot.c    ****   uint8_t writes = 0;
  90:miniboot.c    **** 
  91:miniboot.c    ****   for (uint16_t pos = 0; pos < length; pos += 2) {
  92:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
  93:miniboot.c    ****       writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
  94:miniboot.c    ****       LED_TOGGLE();
  95:miniboot.c    ****       ++writes;
  96:miniboot.c    ****     }
  97:miniboot.c    ****     uint16_t data = getWordFromSource(i2c_address, pos + start_address);
  98:miniboot.c    ****     buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
  99:miniboot.c    ****     buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
 100:miniboot.c    ****   }
 101:miniboot.c    **** 
 102:miniboot.c    ****   for (uint16_t pos = SPM_PAGESIZE -
 103:miniboot.c    ****                       (static_cast<uint16_t>(writes + 1) *
 104:miniboot.c    ****                        static_cast<uint16_t>(SPM_PAGESIZE)) %
 105:miniboot.c    ****                           length;
 106:miniboot.c    ****        pos < SPM_PAGESIZE; ++pos) {
 107:miniboot.c    ****     buf[pos] = 0xFF; // reset contents, since these bytes were not filled in
 108:miniboot.c    ****                      // this page and have value from previous page
 109:miniboot.c    ****   }
 110:miniboot.c    **** 
 111:miniboot.c    ****   writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
 112:miniboot.c    ****   LED_OFF();
 113:miniboot.c    **** }
 114:miniboot.c    **** 
 115:miniboot.c    **** static void leaveBootloader(uint16_t &application_start)
 116:miniboot.c    ****     __attribute__((__noreturn__));
 117:miniboot.c    **** static inline void leaveBootloader(uint16_t &application_start) {
 118:miniboot.c    ****   // hold my beer and watch this!
 119:miniboot.c    ****   reinterpret_cast<void (*)(void)>(application_start)();
 120:miniboot.c    ****   while (1)
 121:miniboot.c    ****     ;
 122:miniboot.c    **** }
 123:miniboot.c    **** 
 124:miniboot.c    **** static inline bool isReflashNecessary(uint32_t &i2c_application_timestamp) {
 125:miniboot.c    ****   uint32_t current_application_timestamp =
 126:miniboot.c    ****       readLatestApplicationTimestampFromInternalEeprom();
 127:miniboot.c    **** 
 128:miniboot.c    ****   i2c_application_timestamp =
 129:miniboot.c    ****       static_cast<uint32_t>(getWordFromSource(
 130:miniboot.c    ****           source_i2c_address_for_program, timestamp_application_byte_offset))
 131:miniboot.c    ****       << 16;
 132:miniboot.c    ****   i2c_application_timestamp |= static_cast<uint32_t>(getWordFromSource(
 133:miniboot.c    ****       source_i2c_address_for_program, timestamp_application_byte_offset + 2));
 134:miniboot.c    **** 
 135:miniboot.c    ****   if (eeprom_not_programmed == current_application_timestamp)
 136:miniboot.c    ****     return true;
 137:miniboot.c    ****   if (i2c_application_timestamp > current_application_timestamp)
 138:miniboot.c    ****     return true;
 139:miniboot.c    ****   return false;
 140:miniboot.c    **** }
 141:miniboot.c    **** 
 142:miniboot.c    **** int main() {
 858               		.loc 1 142 0
 859               		.cfi_startproc
 860 0000 CF93      		push r28
 861               	.LCFI39:
 862               		.cfi_def_cfa_offset 3
 863               		.cfi_offset 28, -2
 864 0002 DF93      		push r29
 865               	.LCFI40:
 866               		.cfi_def_cfa_offset 4
 867               		.cfi_offset 29, -3
 868 0004 CDB7      		in r28,__SP_L__
 869 0006 DEB7      		in r29,__SP_H__
 870               	.LCFI41:
 871               		.cfi_def_cfa_register 28
 872 0008 C258      		subi r28,-126
 873 000a D109      		sbc r29,__zero_reg__
 874               	.LCFI42:
 875               		.cfi_def_cfa_offset 134
 876 000c 0FB6      		in __tmp_reg__,__SREG__
 877 000e F894      		cli
 878 0010 DEBF      		out __SP_H__,r29
 879 0012 0FBE      		out __SREG__,__tmp_reg__
 880 0014 CDBF      		out __SP_L__,r28
 881               	/* prologue: function */
 882               	/* frame size = 130 */
 883               	/* stack size = 132 */
 884               	.L__stack_usage = 132
 885               	.LBB95:
 886               	.LBB96:
 887               	.LBB97:
 888               	.LBB98:
 889               	.LBB99:
 890               		.file 6 "init.h"
   1:init.h        **** #pragma once
   2:init.h        **** 
   3:init.h        **** #include "I2C-master-lib/i2c_master.h"
   4:init.h        **** #include "io.h"
   5:init.h        **** #include <avr/wdt.h>
   6:init.h        **** 
   7:init.h        **** static void initIO() { LED_INIT(); }
   8:init.h        **** 
   9:init.h        **** static void disableWatchdog() {
  10:init.h        ****   wdt_reset();
 891               		.loc 6 10 0
 892               	/* #APP */
 893               	 ;  10 "init.h" 1
 894 0016 A895      		wdr
 895               	 ;  0 "" 2
  11:init.h        ****   MCUSR = 0;
 896               		.loc 6 11 0
 897               	/* #NOAPP */
 898 0018 14BE      		out 0x34,__zero_reg__
  12:init.h        ****   WDTCSR |= (1 << WDCE) | (1 << WDE);
 899               		.loc 6 12 0
 900 001a 8091 6000 		lds r24,96
 901 001e 8861      		ori r24,lo8(24)
 902 0020 8093 6000 		sts 96,r24
  13:init.h        ****   WDTCSR = 0;
 903               		.loc 6 13 0
 904 0024 1092 6000 		sts 96,__zero_reg__
  14:init.h        ****   asm("cli");
 905               		.loc 6 14 0
 906               	/* #APP */
 907               	 ;  14 "init.h" 1
 908 0028 F894      		cli
 909               	 ;  0 "" 2
 910               	/* #NOAPP */
 911               	.LBE99:
 912               	.LBE98:
  15:init.h        **** }
  16:init.h        **** 
  17:init.h        **** static void init() {
  18:init.h        ****   disableWatchdog();
  19:init.h        ****   i2c_init();
 913               		.loc 6 19 0
 914 002a 0E94 0000 		call _Z8i2c_initv
 915               	.LVL77:
 916               	.LBB100:
 917               	.LBB101:
   7:init.h        **** 
 918               		.loc 6 7 0
 919 002e 289A      		sbi 0x5,0
 920 0030 81E0      		ldi r24,lo8(1)
 921 0032 84B9      		out 0x4,r24
 922               	.LBE101:
 923               	.LBE100:
 924               	.LBE97:
 925               	.LBE96:
 143:miniboot.c    **** 
 144:miniboot.c    ****   init();
 145:miniboot.c    **** 
 146:miniboot.c    ****   uint32_t i2c_application_timestamp;
 147:miniboot.c    ****   uint16_t application_start = 0;
 926               		.loc 1 147 0
 927 0034 CF57      		subi r28,lo8(-129)
 928 0036 DF4F      		sbci r29,hi8(-129)
 929 0038 1982      		std Y+1,__zero_reg__
 930 003a 1882      		st Y,__zero_reg__
 931 003c C158      		subi r28,lo8(129)
 932 003e D040      		sbci r29,hi8(129)
 933               	.LVL78:
 934               	.LBB102:
 935               	.LBB103:
 936               	.LBB104:
 126:miniboot.c    **** 
 937               		.loc 1 126 0
 938 0040 0E94 0000 		call _Z48readLatestApplicationTimestampFromInternalEepromv
 939               	.LVL79:
 940 0044 4B01      		movw r8,r22
 941 0046 5C01      		movw r10,r24
 942               	.LVL80:
 130:miniboot.c    ****       << 16;
 943               		.loc 1 130 0
 944 0048 84E1      		ldi r24,lo8(20)
 945 004a 90E0      		ldi r25,0
 946 004c 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 947               	.LVL81:
 131:miniboot.c    ****   i2c_application_timestamp |= static_cast<uint32_t>(getWordFromSource(
 948               		.loc 1 131 0
 949 0050 2C01      		movw r4,r24
 950 0052 612C      		mov r6,__zero_reg__
 951 0054 712C      		mov r7,__zero_reg__
 952 0056 7201      		movw r14,r4
 953 0058 DD24      		clr r13
 954 005a CC24      		clr r12
 955               	.LVL82:
 133:miniboot.c    **** 
 956               		.loc 1 133 0
 957 005c 86E1      		ldi r24,lo8(22)
 958 005e 90E0      		ldi r25,0
 959 0060 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 960               	.LVL83:
 961 0064 2C01      		movw r4,r24
 962 0066 612C      		mov r6,__zero_reg__
 963 0068 712C      		mov r7,__zero_reg__
 964 006a 4C28      		or r4,r12
 965 006c 5D28      		or r5,r13
 966 006e 6E28      		or r6,r14
 967 0070 7F28      		or r7,r15
 968               	.LVL84:
 135:miniboot.c    ****     return true;
 969               		.loc 1 135 0
 970 0072 2FEF      		ldi r18,-1
 971 0074 8216      		cp r8,r18
 972 0076 9206      		cpc r9,r18
 973 0078 A206      		cpc r10,r18
 974 007a B206      		cpc r11,r18
 975 007c 01F0      		breq .L33
 137:miniboot.c    ****     return true;
 976               		.loc 1 137 0
 977 007e 8414      		cp r8,r4
 978 0080 9504      		cpc r9,r5
 979 0082 A604      		cpc r10,r6
 980 0084 B704      		cpc r11,r7
 981 0086 00F0      		brlo .L33
 982               	.L34:
 983               	.LBE104:
 984               	.LBE103:
 985               	.LBB105:
 148:miniboot.c    **** 
 149:miniboot.c    ****   if (isReflashNecessary(i2c_application_timestamp) &&
 150:miniboot.c    ****       isCrcOk(source_i2c_address_for_program)) {
 151:miniboot.c    ****     eraseApplication();
 152:miniboot.c    ****     writeFlashFromI2C(source_i2c_address_for_program, application_start);
 153:miniboot.c    ****     writeLatestApplicationTimestampToInternalEeprom(i2c_application_timestamp);
 154:miniboot.c    ****   } else {
 155:miniboot.c    ****     uint16_t address_in_external_eeprom = getWordFromSource(
 156:miniboot.c    ****         source_i2c_address_for_program, application_start_address_byte_offset);
 986               		.loc 1 156 0
 987 0088 84E2      		ldi r24,lo8(36)
 988 008a 90E0      		ldi r25,0
 989 008c 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 990               	.LVL85:
 157:miniboot.c    **** 
 158:miniboot.c    ****     application_start = address_in_external_eeprom >> 8;
 991               		.loc 1 158 0
 992 0090 092F      		mov r16,r25
 993 0092 10E0      		ldi r17,0
 159:miniboot.c    ****     application_start |= static_cast<uint8_t>(address_in_external_eeprom);
 994               		.loc 1 159 0
 995 0094 082B      		or r16,r24
 996 0096 CF57      		subi r28,lo8(-129)
 997 0098 DF4F      		sbci r29,hi8(-129)
 998 009a 1983      		std Y+1,r17
 999 009c 0883      		st Y,r16
 1000 009e C158      		subi r28,lo8(129)
 1001 00a0 D040      		sbci r29,hi8(129)
 1002               	.LVL86:
 1003               	.L42:
 1004               	.LBE105:
 1005               	.LBE102:
 1006               	.LBB117:
 1007               	.LBB118:
 119:miniboot.c    ****   while (1)
 1008               		.loc 1 119 0
 1009 00a2 CF57      		subi r28,lo8(-129)
 1010 00a4 DF4F      		sbci r29,hi8(-129)
 1011 00a6 E881      		ld r30,Y
 1012 00a8 F981      		ldd r31,Y+1
 1013 00aa C158      		subi r28,lo8(129)
 1014 00ac D040      		sbci r29,hi8(129)
 1015 00ae 0995      		icall
 1016               	.LVL87:
 1017               	.L43:
 1018 00b0 00C0      		rjmp .L43
 1019               	.LVL88:
 1020               	.L33:
 1021               	.LBE118:
 1022               	.LBE117:
 1023               	.LBB119:
 150:miniboot.c    ****     eraseApplication();
 1024               		.loc 1 150 0
 1025 00b2 0E94 0000 		call _ZL7isCrcOkh.constprop.3
 1026               	.LVL89:
 149:miniboot.c    ****       isCrcOk(source_i2c_address_for_program)) {
 1027               		.loc 1 149 0
 1028 00b6 8823      		tst r24
 1029 00b8 01F0      		breq .L34
 1030 00ba E0E0      		ldi r30,0
 1031 00bc F8E7      		ldi r31,lo8(120)
 1032               	.LBB106:
 1033               	.LBB107:
  12:flash.h       ****     boot_spm_busy_wait();
 1034               		.loc 2 12 0
 1035 00be 83E0      		ldi r24,lo8(3)
 1036               	.L36:
 1037               	.LVL90:
  11:flash.h       ****     boot_page_erase(ptr);
 1038               		.loc 2 11 0
 1039 00c0 E058      		subi r30,-128
 1040 00c2 F109      		sbc r31,__zero_reg__
 1041               	.LVL91:
  12:flash.h       ****     boot_spm_busy_wait();
 1042               		.loc 2 12 0
 1043               	/* #APP */
 1044               	 ;  12 "flash.h" 1
 1045 00c4 8093 5700 		sts 87, r24
 1046 00c8 E895      		spm
 1047               		
 1048               	 ;  0 "" 2
 1049               	/* #NOAPP */
 1050               	.L35:
  13:flash.h       ****   } while (ptr);
 1051               		.loc 2 13 0
 1052 00ca 07B6      		in __tmp_reg__,0x37
 1053 00cc 00FC      		sbrc __tmp_reg__,0
 1054 00ce 00C0      		rjmp .L35
  10:flash.h       ****     ptr -= SPM_PAGESIZE;
 1055               		.loc 2 10 0
 1056 00d0 3097      		sbiw r30,0
 1057 00d2 01F4      		brne .L36
  15:flash.h       **** }
 1058               		.loc 2 15 0
 1059               	/* #APP */
 1060               	 ;  15 "flash.h" 1
 1061 00d4 A895      		wdr
 1062               	 ;  0 "" 2
 1063               	.LVL92:
 1064               	/* #NOAPP */
 1065               	.LBE107:
 1066               	.LBE106:
 1067               	.LBB108:
 1068               	.LBB109:
 1069               	.LBB110:
 1070               	.LBB111:
  17:miniboot.c    **** }
 1071               		.loc 1 17 0
 1072 00d6 80E2      		ldi r24,lo8(32)
 1073 00d8 90E0      		ldi r25,0
 1074 00da 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 1075               	.LVL93:
 1076 00de 5C01      		movw r10,r24
 1077               	.LVL94:
 1078               	.LBE111:
 1079               	.LBE110:
 1080               	.LBB112:
  91:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
 1081               		.loc 1 91 0
 1082 00e0 00E0      		ldi r16,0
 1083 00e2 10E0      		ldi r17,0
 1084               	.LBE112:
  89:miniboot.c    **** 
 1085               		.loc 1 89 0
 1086 00e4 812C      		mov r8,__zero_reg__
 1087               	.LVL95:
 1088 00e6 CE01      		movw r24,r28
 1089 00e8 0196      		adiw r24,1
 1090 00ea 7C01      		movw r14,r24
 1091               	.LBB115:
 1092               	.LBB113:
  94:miniboot.c    ****       ++writes;
 1093               		.loc 1 94 0
 1094 00ec 9924      		clr r9
 1095 00ee 9394      		inc r9
 1096               	.LVL96:
 1097               	.L37:
 1098               	.LBE113:
  91:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
 1099               		.loc 1 91 0
 1100 00f0 0A15      		cp r16,r10
 1101 00f2 1B05      		cpc r17,r11
 1102 00f4 00F4      		brsh .L53
 1103 00f6 6801      		movw r12,r16
 1104 00f8 E894      		clt
 1105 00fa C7F8      		bld r12,7
 1106 00fc DD24      		clr r13
 1107               	.LBB114:
  92:miniboot.c    ****       writeToFlash(writes * SPM_PAGESIZE, &buf[0], application_start);
 1108               		.loc 1 92 0
 1109 00fe 0115      		cp r16,__zero_reg__
 1110 0100 1105      		cpc r17,__zero_reg__
 1111 0102 01F0      		breq .L38
 1112 0104 C114      		cp r12,__zero_reg__
 1113 0106 D104      		cpc r13,__zero_reg__
 1114 0108 01F4      		brne .L38
  93:miniboot.c    ****       LED_TOGGLE();
 1115               		.loc 1 93 0
 1116 010a AE01      		movw r20,r28
 1117 010c 4F57      		subi r20,127
 1118 010e 5F4F      		sbci r21,-1
 1119 0110 B701      		movw r22,r14
 1120 0112 20E8      		ldi r18,lo8(-128)
 1121 0114 829E      		mul r8,r18
 1122 0116 C001      		movw r24,r0
 1123 0118 1124      		clr __zero_reg__
 1124 011a 0E94 0000 		call _ZL12writeToFlashjPhRj
 1125               	.LVL97:
  94:miniboot.c    ****       ++writes;
 1126               		.loc 1 94 0
 1127 011e 85B1      		in r24,0x5
 1128 0120 8925      		eor r24,r9
 1129 0122 85B9      		out 0x5,r24
  95:miniboot.c    ****     }
 1130               		.loc 1 95 0
 1131 0124 8394      		inc r8
 1132               	.LVL98:
 1133               	.L38:
  97:miniboot.c    ****     buf[pos % SPM_PAGESIZE] = static_cast<uint8_t>(data >> 8);
 1134               		.loc 1 97 0
 1135 0126 C801      		movw r24,r16
 1136 0128 8296      		adiw r24,34
 1137 012a 0E94 0000 		call _ZL17getWordFromSourcehj.constprop.5
 1138               	.LVL99:
  98:miniboot.c    ****     buf[(pos + 1) % SPM_PAGESIZE] = static_cast<uint8_t>(data);
 1139               		.loc 1 98 0
 1140 012e F701      		movw r30,r14
 1141 0130 EC0D      		add r30,r12
 1142 0132 FD1D      		adc r31,r13
 1143 0134 9083      		st Z,r25
 1144 0136 F801      		movw r30,r16
 1145 0138 3196      		adiw r30,1
  99:miniboot.c    ****   }
 1146               		.loc 1 99 0
 1147 013a EF77      		andi r30,127
 1148 013c FF27      		clr r31
 1149 013e EE0D      		add r30,r14
 1150 0140 FF1D      		adc r31,r15
 1151 0142 8083      		st Z,r24
 1152               	.LBE114:
  91:miniboot.c    ****     if (pos > 0 && (0 == (pos % SPM_PAGESIZE))) {
 1153               		.loc 1 91 0
 1154 0144 0E5F      		subi r16,-2
 1155 0146 1F4F      		sbci r17,-1
 1156               	.LVL100:
 1157 0148 00C0      		rjmp .L37
 1158               	.LVL101:
 1159               	.L53:
 1160               	.LBE115:
 1161               	.LBB116:
 103:miniboot.c    ****                        static_cast<uint16_t>(SPM_PAGESIZE)) %
 1162               		.loc 1 103 0
 1163 014a 282D      		mov r18,r8
 1164 014c 30E0      		ldi r19,0
 1165 014e C901      		movw r24,r18
 1166 0150 0196      		adiw r24,1
 1167 0152 9695      		lsr r25
 1168 0154 982F      		mov r25,r24
 1169 0156 8827      		clr r24
 1170 0158 9795      		ror r25
 1171 015a 8795      		ror r24
 104:miniboot.c    ****                           length;
 1172               		.loc 1 104 0
 1173 015c B501      		movw r22,r10
 1174 015e 0E94 0000 		call __udivmodhi4
 105:miniboot.c    ****        pos < SPM_PAGESIZE; ++pos) {
 1175               		.loc 1 105 0
 1176 0162 F701      		movw r30,r14
 1177 0164 E81B      		sub r30,r24
 1178 0166 F90B      		sbc r31,r25
 1179 0168 E058      		subi r30,-128
 1180 016a FF4F      		sbci r31,-1
 107:miniboot.c    ****                      // this page and have value from previous page
 1181               		.loc 1 107 0
 1182 016c 4FEF      		ldi r20,lo8(-1)
 1183               	.LVL102:
 1184               	.L40:
 1185 016e CF01      		movw r24,r30
 1186 0170 8E19      		sub r24,r14
 1187 0172 9F09      		sbc r25,r15
 102:miniboot.c    ****                       (static_cast<uint16_t>(writes + 1) *
 1188               		.loc 1 102 0
 1189 0174 8038      		cpi r24,-128
 1190 0176 9105      		cpc r25,__zero_reg__
 1191 0178 00F4      		brsh .L54
 107:miniboot.c    ****                      // this page and have value from previous page
 1192               		.loc 1 107 0
 1193 017a 4193      		st Z+,r20
 1194 017c 00C0      		rjmp .L40
 1195               	.L54:
 1196               	.LBE116:
 111:miniboot.c    ****   LED_OFF();
 1197               		.loc 1 111 0
 1198 017e AE01      		movw r20,r28
 1199 0180 4F57      		subi r20,127
 1200 0182 5F4F      		sbci r21,-1
 1201 0184 B701      		movw r22,r14
 1202 0186 C901      		movw r24,r18
 1203 0188 9695      		lsr r25
 1204 018a 982F      		mov r25,r24
 1205 018c 8827      		clr r24
 1206 018e 9795      		ror r25
 1207 0190 8795      		ror r24
 1208 0192 0E94 0000 		call _ZL12writeToFlashjPhRj
 1209               	.LVL103:
 112:miniboot.c    **** }
 1210               		.loc 1 112 0
 1211 0196 289A      		sbi 0x5,0
 1212               	.LBE109:
 1213               	.LBE108:
 153:miniboot.c    ****   } else {
 1214               		.loc 1 153 0
 1215 0198 C301      		movw r24,r6
 1216 019a B201      		movw r22,r4
 1217 019c 0E94 0000 		call _Z47writeLatestApplicationTimestampToInternalEepromm
 1218               	.LVL104:
 1219 01a0 00C0      		rjmp .L42
 1220               	.LBE119:
 1221               	.LBE95:
 1222               		.cfi_endproc
 1223               	.LFE23:
 1225               		.text
 1226               	.Letext0:
 1227               		.file 7 "c:\\mihai\\progs\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\
 1228               		.file 8 "config.h"
 1229               		.file 9 "io.h"
 1230               		.file 10 "I2C-master-lib/i2c_master.h"
 1231               		.file 11 "c:\\mihai\\progs\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\
DEFINED SYMBOLS
                            *ABS*:00000000 miniboot.c
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:2      *ABS*:0000003e __SP_H__
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:3      *ABS*:0000003d __SP_L__
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:4      *ABS*:0000003f __SREG__
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:11     .text:00000000 _ZL12writeToFlashjPhRj
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:173    .text:00000098 _Z47writeLatestApplicationTimestampToInternalEepromm
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:252    .text:000000ec _Z48readLatestApplicationTimestampFromInternalEepromv
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:344    .text:0000014c _Z8readBytehj
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:423    .text:00000190 _ZL17getWordFromSourcehj.constprop.5
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:487    .text:000001c6 _ZL7isCrcOkh.constprop.3
C:\Users\Mihai\AppData\Local\Temp\ccZeXcNv.s:856    .text.startup:00000000 main

UNDEFINED SYMBOLS
eeprom_write_byte
eeprom_read_byte
_Z9i2c_starth
_Z9i2c_writeh
_Z8i2c_stopv
_Z12i2c_read_ackv
_Z8i2c_initv
__udivmodhi4
